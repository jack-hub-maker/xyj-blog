## 让人迷惑的闭包

闭包是 JavaScript 中一个非常容易让人迷惑的知识点：

这里有一段《你不知道的 JavaScript（上）》作者写的一段话

![image.png](https://img11.360buyimg.com/ddimg/jfs/t1/78783/10/16944/233522/6136112eE4274bc84/20f65d7a9588efec.png)

闭包确实是 JavaScript 中一个很难理解的知识点，接下来我们就对其一步步来进行剖析，看看它到底有什么神奇之
处。

## JS 中函数是一等公民

在 JavaScript 中，函数是非常重要的，并且是一等公民：

- 那么就意味着函数的使用是非常灵活的；
- 函数可以作为另外一个函数的参数，也可以作为另外一个函数的返回值来使用；

你可以使用内置的高阶函数

还可以自己编写高阶函数

高阶函数就是把一个函数作为另一个函数的返回值，或者把把一个函数作为另一个函数的参数

## JS 中闭包的定义

这里先来看一下闭包的定义，分成两个：在计算机科学中和在 JavaScript 中。

在计算机科学中对闭包的定义（维基百科）：

- 闭包（英语：Closure），又称**词法闭包**（Lexical Closure）或**函数闭包**（function closures）；
- 是在支持 **头等函数** 的编程语言中，实现词法绑定的一种技术；
- 闭包在实现上是一个结构体，它存储了一个函数和一个关联的环境（相当于一个符号查找表）；
- 闭包跟函数最大的区别在于，当捕捉闭包的时候，它的 **自由变量** 会在捕捉时被确定，这样即使脱离了捕捉时的上下文，它也能照常运行；

闭包的概念出现于 60 年代，最早实现闭包的程序是 Scheme，那么我们就可以理解为什么 JavaScript 中有闭包：

因为 JavaScript 中有大量的设计是来源于 Scheme 的；

我们再来看一下 MDN 对 JavaScript 闭包的解释：

- 一个函数和对其周围状态（lexical environment，**词法环境**）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）；
- 也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域；
- 在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来；

那么我的理解和总结：

- 一个普通的函数 function，如果它可以访问外层作用于的自由变量，那么这个函数就是一个闭包；
- 从广义的角度来说：JavaScript 中的函数都是闭包；
- 从狭义的角度来说：JavaScript 中一个函数，如果访问了外层作用域的变量，那么它是一个闭包；

> [!tip]
> 看上面的话可能会有点懵，不急先看看后面通过内存的角度来解析闭包，之后再回来你就可以理解上面的话了

## 闭包的访问过程

如果我们编写了如下的代码，它一定是形成了闭包的：

```js
var age = 19;
function foo() {
  function bar() {
    console.log(age);
  }
  return bar;
}
var fn = foo();
fn();
```

因为我们前面说过嘛，一个函数访问了外层作用域的变量，那么它就是一个闭包

接下来我们通过内存图来看看这个函数是如何访问的

学习了前面的知识，应该对内存的概念是比较清晰了，我就直接放出我自己画的内存图

![image.png](https://img10.360buyimg.com/ddimg/jfs/t1/204844/34/5150/77871/6136c6c8Eef5b8e97/997fc815a8a10178.png)

正常情况下 foo 执行完毕，foo 就会被弹出栈，也就意味 FOO 的 VO 没有指向堆内存的 AO 了，那我们的 foo AO 是不是也应该要被销毁

但是 FOO AO 并没有被销毁，这是为什么

前面我们不是讲过 JS 的内存管理吗，GC 算法的标记算法会从根对象开始（也就是 GO），相对于从 GO 开始连线，没有连到的就会被 GC 回收掉

根据内存图可知 Foo AO 在 GO 那条线上，所以不会被 GC 回收掉

## 闭包的内存泄露

我们可能经常会听到闭包**可能**会造成内存泄漏

- 在上面的案例中，如果 foo 只用一次，那么我们是不是想让该函数对象的 AO 被销毁掉，让它不占内存
- 但是因为 GC 算法无法对它进行回收
- 因为我们不用它了，它一直在内存中，久而久之就可能造成内存泄漏
- 所以我们经常会听到闭包会造成内存泄漏

我的理解是：

- 内存泄漏是你不用它的时候可能会造成内存泄漏
- 但是如果你偶尔或者经常要使用它的话，就不会造成内存泄漏

那么如何解决这个问题喃?

- 这个时候你可以把 foo = null，null 可以理解为 foo 执行了其它地方的 0x00 地址
- 这个时候 GO 的 GC 线上就没有 foo 了，在下一次的 GC 回收中，foo 就会被销毁掉
