<!--
 * @Descripttion: 
 * @version: 1.0
 * @Author: 
 * @Date: 2022-02-15 10:14:30
 * @LastEditors: YingJie Xing
 * @LastEditTime: 2022-06-14 11:01:30
 * @FilePath: /sandy.gitee.io/docs/interview/scene/2022.md
 * Copyright 2022 YingJie Xing, All Rights Reserved. 
-->
# 2022 年前端面试分享

## 记录一些遇到的笔试和面试题💗

**题目以及解答**

介绍项目
安全性
token： 验证 处理令牌续期问题，在header中获取到新令牌时，替换老令牌，以达到用户无感刷新令牌
        1、第一次登录的时候，前端调后端的登陆接口，发送用户名和密码
        2、后端收到请求，验证用户名和密码，验证成功，就给前端返回一个token
        3、前端拿到token，将token存储到localStorage和前端中，并跳转路由页面
        4、前端每次跳转路由，就判断 localStroage 中有无 token ，没有就跳转到登录页面，有则跳转到对应路由页面
        5、每次调后端接口，都要在请求头中加token
        6、后端判断请求头中有无token，有token，就拿到token并验证token，验证成功就返回数据，验证失败（例如：token过期）就返回401，请求头中没有token也返回401
        7、如果前端拿到状态码为401，就清除token信息并跳转到登录页面

请求拦截器： request.interceptors.request.use 登录外的大部分请求体添加 token 以及sha256加密 （消息摘要）
    增加图像验证码 3 1 纯前端随机数据 通过css旋转做到 2 后端返回图片 登录的时候带上 3 滑块 
    加密 sha256  base64 

request：
    1 请求拦截request.interceptors.request.use
    2 响应拦截
        后台默认返回转json格式，blob等其他格式需要转响应头
        刷新token


1 401 未授权 
    1  如果未授权  重定向首页 移除

umi+dva
dva 是基于redux，redux-saga react-router 的轻量级前端框架   redux用于处理仓库的同步数据，redux-sage用于处理仓库的异步数据，react-router用于页面跳转
特点约定式的组织model组织
按钮权限控制
1 后端协助  路由跳转调用接口 返回对应菜单路由的配置按钮
2  调用接口在dva中配置  subscriptions 订阅监听路由  然后dispath调用异步方法
3  二次封装button组件（该组件connect 调用dva 获取 当前路由按钮数据state  与组件props传值比较）每次调用 判断传值btnJurisdiction  如果没有权限或者权限禁用返回null 反之就正常输出button
准确来说 按钮 要为路由模块 准确的说是每一个菜单路由配置所需按钮  在同时为用户角色  配置响应菜单的时候 配置生效的按钮
菜单路由配置按钮时  按钮数据源来于前端代码 限制死 ant-d 自动完成输入下拉框 后端负责保存对应菜单 按钮配置 以及角色路由和按钮配置 形成一个闭环
路由权限控制
1 menu通过后端 请求返回该用户需要的菜单 树形结点类型的数据   生成菜单结构
2  地址栏输入  比较保存在dva全局中的菜单数据 使用history.block 拦截 类似于 路由拦截beforeeach
3  系统管理保存 用户路由权限的做法 一般是前后台一致    比如前端除了代码中的配置 路由path 名称自己输入 还要保存到后端。 我不知道别的系统是咋样的刚进来的公司系统是 管理员需要输入资源 前端约束的路由path name 以及固定父子关系。 这里是改成了资源路由类型 用户纯输入路由的name 以及排序所在父级中文名。用户只需获取   config/routes 的name  （写了个递归 判断了下权限路由 下面的路由push 到一个数组 然后递归下把每一个tree格式数组铺平）  传给后端数据其实还是一个path 一个name 一些其他的
4    配完之后在角色那里配置 传给后端 形成闭环
5  后面菜单跳转的时候 回来最开始 这里有一个主意的点 要自定义菜单点击方法 不能用他原来的方法 点击的的时候让他push 或者弄个link跳转
第一层 行业管理  设置多个行业 这个行业是固定。（高校，档案馆） 行业下面的一层是平台 可以理解为某一个具体的甲方  或者（甲方所具有的多功能系统） 在下面 注册的一些配置  比如系统网段局域网政务网 滑块登录  主题一些可以做的个性化需求之间的区分等  区分角色管理 配置权限（细化按钮 路由）   菜单 里面再配置（每一个菜单的按钮权限 ） 用户这边组织机构区分
1 react 中的虚拟dom 与 真实dom
1 虚拟dom 一般都是一个对象 ，每次 dom 的更改就变成了 js 对象的属性的更改，这样一来就能查找 js 对象的属性变化，要比查询 dom 树的性能开销小。，虚假DOM比较“轻”。但是后者需要遍历整个dom树
2无需真实DOM上那么多的属性，也就说修改虚假dom的代价小于真实DOM
3，虚假DOM最终会被React转化为真实DOM，呈现在页面上。
CF 普通的真实dom作增删改时会引起浏览器的重排和重绘。 现在几大主流框架都实现了虚拟dom，并且实现了新旧节点比较，这就解决了以前多次重排重绘的问题，且减少了代码量。 ref 虚拟 document真实
为什么使用虚拟dom
    在一次操作中，我需要更新10个DOM节点，浏览器收到第一个DOM请求后并不知道还有9次更新操作，因此会马上执行流程，最终执行10次。第一次计算完，紧接着下一个DOM更新请求，这个节点的坐标值就变了，前一次计算为无用功。计算DOM节点坐标值等都是白白浪费的性能。
    而虚拟DOM不会立即操作DOM，而是将这10次更新的diff内容保存到本地一个JS对象中，最终将这个JS对象一次性attch到DOM树上，再进行后续操作，避免大量无谓的计算量。
    1.vdom 的真正意义是为了实现跨平台，服务端渲染（从而诞生了react native等）；
    2.提供一个性能还算不错 Dom 更新策略

2 从接受html到页面显示的流程
1.创建DOM树（分析HTML元素，构建一颗DOM树）
2.创建StyleRules（分析CSS文件和元素上的inline样式，生成页面的样式表）

3 执行JavaScript：加载并执行JavaScript代码（包括内联代码或外联JavaScript文件）；
4.创建Render树（将DOM树和样式表，关联起来）
5.布局Layout（浏览器开始布局，为每个Render树上的节点确定一个在显示屏上出现的精确坐标）
6.绘制Painting（调用每个节点paint方法，把它们绘制出来）
3  diff算法 循环递归进行依次对比
diff算法就是用JavaScript来表示一个dom树的结构
然后用这个dom去构建一个真实的dom 插入到文档中
当状态变更的时候 重新构造一个dom树 比较新旧dom树 记录两个dom树的差异 并且通知视图开始更新
diff算法就 用来比较vdom结构的
1把树形结构按照层级分解，只比较同级元素
2通过给列表结构的每个单元添加的唯一 key值进行区分同层次的子节点的比较。调用patch函数，比较新旧节点，一边比较一边给真实的DOM打补丁
3React 只会匹配相同 class 的 component（这里面的 class 指的是组件的名字）
4合并操作，调用 component 的 setState 方法的时候, React 将其标记为 dirty. 到每一个事件循环结束, React 检查所有标记 dirty 的 component 重新绘制。
5 选择性渲染。开发人员可以重写 shouldComponentUpdate 提高 diff 的性能。
实现vdom的两种核心API： h函数、patch函数。
diff算法实现的过程就是调用patch函数，比较新旧节点，一边比较一边给真实的DOM打补丁。patch函数有两个参数，vnode和oldVnode，也就是新旧两个虚拟节点。
diff算法是在render里面进行计算的。
优化虚拟dom 转化真实dom的最少操作过程 叫调和 react用tree diff(树比较)、component diff（组件比较）、element diff（元素比较）三大策略将O(n^3)的复杂度转化为O(n)的复杂度
三个策略
(1)Web UI中DOM节点跨层级的移动操作特别少，可以忽略不计
(2)拥有相同类的俩个组件将会生成相似的树形结构，拥有不同类的俩个组件将会生成不同的树形结构。
(3)对于同一层级的一组子节点，它们可以通过唯一id进行区分
1 （tree diff）
    react通过updateDepth对virtual DOM树进行层级控制
    对树分层进行比较，两棵树只对同一层的节点进行比较，如果节点不存在，则删除这个节点以及此节点下所有子节点，不会再进一步比较
    只需遍历一次，就能完成整棵DOM树的比较

2（component diff）：
    react对不同组件间的比较，有两类策略：
    组件变化时，如果 virtual dom 没变，可通过 shouldComponentUpdate 方法控制是否需要 diff 运算
    组件类不同（结构相似），则判断为 dirty component（脏组件），整个替换

3 （element diff）
    当节点处于同一层级时，提供三种节点操作：删除、插入、移动
        React通过制定大胆的diff策略，将 O(n3) 复杂度的问题转换成 O(n) 复杂度的问题；
            React是如何将O(n3) 复杂度的问题转换成 O(n) 的？
            只进行同级比较
            不同类的React组件会被当做完全不同的DOM结构而被完全替换
            key prop：开发人员可以通过给Virtual DOM一个唯一的key属性暗示React这是同一个DOM结构，反之若key值不同则会被当做完全不同的DOM结构。
            React通过分层求异的策略，对tree diff进行算法优化；
            React通过相同类生成相似树形结构，不同类生成不同树形结构的策略，对component diff进行算法优化。
            React通过设置唯一key的策略，对element diff进行算法优化；
            建议，在开发组件时，保持稳定的DOM结构会有助于性能的提升；
            建议，在开发过程中，尽量减少类似将最后一个节点移动到列表首部的操作，当节点数量过大或更新操作过于频繁时，在一定程度上会影响React的渲染性能。

4  宏任务微任务
宏任务包括：setTimeout setInterval Ajax DOM事件
微任务：Promise async/await
macro-task包括：script(整体代码), setTimeout, setInterval, setImmediate, I/O, UI rendering。
micro-task包括：process.nextTick(node 环境非谷歌), Promises, Object.observe  （ 第二个参数的回调方法可以监视第一个参数对象发生变化的过程 可以用notify发通知）, MutationObserver（监听dom结点）。
微任务比宏任务的执行时间要早
主线程 >> 主线程上创建的微任务 >> 主线程上创建的宏任务
1）所有的同步任务都在主线程上执行，行成一个执行栈。
2）除了主线程之外，还存在一个任务列队，只要异步任务有了运行结果，就在任务列队中植入一个时间标记。
3）主线程完成所有任务(执行栈清空），就会读取任务列队，先执行微任务队列在执行宏任务队列。
4）重复上面三步
只要主线程空了，就会读取任务列队，这就是js的运行机制，也被称为 event loop（事件循环）。

执行顺序：先执行同步代码，遇到异步宏任务则将异步宏任务放入宏任务队列中，遇到异步微任务则将异步微任务放入微任务队列中，当所有同步代码执行完毕后，再将异步微任务从队列中调入主线程执行，微任务执行完毕后再将异步宏任务从队列中调入主线程执行，一直循环直至所有任务执行完毕。
5 事件循环
1）所有的同步任务都在主线程上执行，行成一个执行栈。
2）除了主线程之外，还存在一个任务列队，只要异步任务有了运行结果，就在任务列队中植入一个时间标记。
3）主线程完成所有任务(执行栈清空），就会读取任务列队，先执行微任务队列在执行宏任务队列。
4）重复上面三步
只要主线程空了，就会读取任务列队，这就是js的运行机制，也被称为 event loop（事件循环）。
事件循环  题目
https://blog.csdn.net/frontend_frank/article/details/115475305?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165381081316780357212870%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=165381081316780357212870&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-115475305-null-null.142^v11^pc_search_result_control_group,157^v12^new_style&utm_term=%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF&spm=1018.2226.3001.4187

6 Fiber  调度策略
1  内存中维护一颗虚拟DOM树，数据变化时（setState），自动更新虚拟 DOM，得到一颗新树，然后 Diff 新老虚拟 DOM 树，找到有变化的部分，得到一个 Change(Patch)，将这个 Patch 加入队列，最终批量更新这些 Patch 到 DOM 中。
2 在组件更新和渲染是有2个过程 reconciler和render阶段： 调和和渲染
调和阶段(Reconciler)：官方解释。React 会自顶向下通过递归，遍历新数据生成新的 Virtual DOM，然后通过 Diff 算法，找到需要变更的元素(Patch)，放到更新队列里面去。
渲染阶段(Renderer)：遍历更新队列，通过调用宿主环境的API，实际更新渲染对应元素。这一个过程是一旦任务开始进行，就无法中断，那么 js 将一直占用主线程， 一直要等到整棵 Virtual DOM 树计算完成之后，才能把执行权交给渲染引擎，
时间分片(time slicing)和暂停(supense)。
Fiber 把当前需要执行的任务分成一个个微任务，安排优先级，然后依次处理，每过一段时间（非常短，毫秒级）就会暂停当前的任务，查看有没有优先级较高的任务，然后暂停（也可能会完全放弃）掉之前的执行结果，跳出到下一个微任务
ReactDOM.render() 和 setState 的时候开始创建更新。
将创建的更新加入任务队列，等待调度。
在 requestIdleCallback 空闲时执行任务。
从根节点开始遍历 Fiber Node，并且构建 WokeInProgress Tree。
生成 effectList。
根据 EffectList 更新 DOM。
Time Slicing 时间分片和Suspense。
 
Fiber Reconciler 在阶段一进行 Diff 计算的时候，会生成一棵 Fiber 树。这棵树是在 Virtual DOM 树的基础上增加额外的信息来生成的，它本质来说是一个链表。
在react中，主要做了以下的操作：
为每个增加了优先级，优先级高的任务可以中断低优先级的任务。然后再重新，注意是重新执行优先级低的任务
增加了异步任务，调用requestIdleCallback api，浏览器空闲的时候执行
dom diff树变成了链表，一个dom对应两个fiber（一个链表），对应两个队列，这都是为找到被中断的任务，重新执行
更新过程中首先, 当前是哪个组件触发的更新, React 是知道的( this 指向), 于是 React 会针对当前组件计算其相应的到期时间(上面提到了计算方法), 并且基于这个到期时间, 创建一个更新 update , 将引起改变的 payload (比如说 state/props ), 作为此次更新的一个属性, 并插入当前组件对应的 Fiber Node 的更新队列（它是一个单向链表数据结构。只要有 setState 或者其他方式触发了更新，就会在 fiber 上的 updateQueue 里插入一个 update，这样在更新的时候就可以合并一起更新。

7  hooks
构建自己的Hook可以将组件逻辑提取到可重用的函数中 把每个组件重复的逻辑单独抽离出来
比较常见的自定义hooks useAsync 封装axiosu  useUpdate第一次不渲染数据更新渲染；useForceUpdate：强制更新；useFileView  根据传入 文件类型 URL的路径 返回支持的预览的个文件类型播放器，URL.revokeObjectURL() 静态方法用来释放一个之前已经存在的、通过调用 URL.createObjectURL() 创建的 URL 对象 （Blob 对象 ！需要释放内存）。    另一个就是样式button 返回Button  变量样式 变量样式对应的状态 
useResizeLine 拖拽  监听 鼠标点击onMouseDown  获取clientX 浏览器的X轴坐标   监听onmousemove 鼠标移动获取clientX  算出偏移量
https://ahooks.js.org/zh-CN/hooks/use-mount

React.memo()、useCallback()、useMemo() 区别及基本使用
www.jianshu.com/p/e12013671…
实操题
1 说一说cookie sessionStorage localStorage 区别？
  当用户首次登录成功（注册也是一种可以适用的场景）之后, 服务器端就会生成一个token值，这个值，会在服务器保存token值(保存在数据库中)，再将这个token值返回给客户端。最简单的token组成:uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign(签名，由token的前几位+盐以哈希算法压缩成一定长的十六进制字符串，可以防止恶意第三方拼接token请求服务器)


1.都是浏览器存储 2.都存储在浏览器本地 区别： 1.cookie由服务器写入，CSRF攻击容易获取 sessionStorage以及localStorage都是由前端写入 2.cookie的生命周期由服务器端写入时就设置好的，localStorage是写入就一直存在，除非手动清除，sessionStorage是由页面关闭时自动清除 3.cookie存储空间大小约4kb， sessionStorage及localStorage空间比较大，大约5M 4.3者的数据共享都遵循同源原则，sessionStorage还限制必须是同一个页面 5.前端给后端发送请求时，自动携带cookie, session 及 local都不携带 6.cookie一般存储登录验证信息或者token，localStorage常用于存储不易变动的数据，减轻服务器压力，sessionStorage可以用来监测用户是否是刷新进入页面，如音乐播放器恢复进度条功能

每次打开页面之后，随机生成一个 id，放在变量里面，开始播放音乐之后，把这个 id 写到 cookie 里去，就是 playerid 这个 cookie，播放音乐的过程中，会不断有事件出发，比如说 timeupdate，事件触发的时候看 cookie 中的 playerid 是不是跟页面自己保存这个变量一致。不一致就暂停播放音乐。
sessionStorage
2  JS数据类型有哪些,区别是什么？
JS数据类型分为两类：一类是基本数据类型，也叫简单数据类型，包含7种类型，分别是Number 、String、Boolean、BigInt、Symbol、Null、Undefined。另一类是引用数据类型也叫复杂数据类型，通常用Object代表，普通对象，数组，正则，日期，Math数学函数都属于Object。
数据分成两大类的本质区别：基本数据类型和引用数据类型它们在内存中的存储方式不同。
基本数据类型是直接存储在栈中的简单数据段，占据空间小，属于被频繁使用的数据。
引用数据类型是存储在堆内存中，占据空间大。引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址，当解释器寻找引用值时，会检索其在栈中的地址，取得地址后从堆中获得实体。
加分回答
Symbol每个从Symbol()返回的symbol值都是唯一的。一个symbol值能作为对象属性的标识符；这是该数据类型仅有的目的
    数据的创建方法Symbol()，因为它的构造函数不够完整，所以不能使用new Symbol()创建数据。由于Symbol()创建数据具有唯一性，所以 Symbol() !== Symbol(), 同时使用Symbol数据作为key不能使用for获取到这个key，需要使用Object.getOwnPropertySymbols(obj)获得这个obj对象中key类型是Symbol的key值。

BigInt也是ES6新出的一种数据类型，这种数据类型的特点就是数据涵盖的范围大，能够解决超出普通数据类型范围报错的问题。
    使用方法：
    -整数末尾直接+n：647326483767797n
    -调用BigInt()构造函数：BigInt("647326483767797")
    注意：BigInt和Number之间不能进行混合操作

3 闭包
闭包就是能够读取其他函数内部变量的函数。
闭包：一个作用域有权访问另一个作用域的局部变量，代码上来看就是子函数访问父函数的局部变量并返回的函数。（一个函数内部创建另一个函数，通过另一个函数来访问这个函数的局部变量，利用闭包突破作用域链）。由于 javascript 的特性，外层的函数无法访问内部函数的变量；而内部函数可以访问外部函数的变量（即作用域链）形成一个闭包环境，需要两个条件：函数嵌套，子函数引用父函数局部变量。 闭包带来的问题：由于垃圾回收器不会将闭包中变量销毁，于是就造成了内存泄露，内存泄露积累多了就容易导致内存溢出。
4 promise是什么与使用方法？
Promise是宏任务（同步执行），只有Promise的回调是异步微任务。
promise存在三种状态pending，fulfilled，rejected，
等待(pending)、已完成(fulfilled)、已拒绝(rejected) 
基本使用方法是new Promise((resolve,rejected)=>{}).then(res=>{}).catch(err=>{});调用resolve()会执行then部分，出现错误会执行catch部分，此外promise.all([]).then(rs=>{})还支持顺序执行多个请求,rs的结果是一个请求结果数组。
可以使用Promise构造函数new一个实例，Promise构造函数接收一个函数作为参数，这个函数有两个参数，分别是两个函数 `resolve`和`reject`，`resolve`将Promise的状态由等待变为成功，将异步操作的结果作为参数传递过去；`reject`则将状态由等待转变为失败，在异步操作失败时调用，将异步操作报出的错误作为参数传递过去。实例创建完成后，可以使用`then`方法分别指定成功或失败的回调函数，也可以使用catch捕获失败，then和catch最终返回的也是一个Promise，所以可以链式调用。
1 三个状态 2一旦状态改变，就不会再变，任何时候都可以得到这个结果3 resolve 方法的参数是then中回调函数的参数，reject 方法中的参数是catch中的参数 4. then 方法和 catch方法 只要不报错，返回的都是一个fullfilled状态的promise 
加分点  Promise.resolve() :返回的Promise对象状态为fulfilled，并且将该value传递给对应的then方法。 Promise.reject()：返回一个状态为失败的Promise对象，并将给定的失败信息传递给对应的处理方法。 Promise.all()：返回一个新的promise对象，该promise对象在参数对象里所有的promise对象都成功的时候才会触发成功，一旦有任何一个iterable里面的promise对象失败则立即触发该promise对象的失败。 Promise.any()：接收一个Promise对象的集合，当其中的一个 promise 成功，就返回那个成功的promise的值。 Promise.race()：当参数里的任意一个子promise被成功或失败后，父promise马上也会用子promise的成功返回值或失败详情作为参数调用父promise绑定的相应句柄，并返回该promise对象。

var p1 = new Promise(function (resolve, reject) {
    setTimeout(resolve, 500, 'P1');
});
var p2 = new Promise(function (resolve, reject) {
    setTimeout(resolve, 600, 'P2');
});
// 同时执行p1和p2，并在它们都完成后执行then:
Promise.all([p1, p2]).then(function (results) {
    console.log(results); // 获得一个Array: ['P1', 'P2']
});

5 说一说跨域是什么？如何解决跨域问题？
正向代理：“一台代理服务器"代替了"客户端”，去和"目标服务器"进行交互，即代理客户端。
    用途：隐藏客户端真实IP，突破限制访问外国网站。

反向代理：“一台代理服务器"代替了"目标服务器”，去和"客户端"进行交互，即代理服务端
    用途：隐藏服务器真实IP，提供负载平衡，即指向后端的多台服务器中空闲的一台；
    而我们一般在开发中解决跨域是利用反向代理的原理。例如vue项目中配置proxy代理或者nginx配置反向代理。

同源限制、协议、域名、端口、CORS、node中间件、JSONP、postmessage
跨域：当前页面中的某个接口请求的地址和当前页面的地址如果协议、域名、端口其中有一项不同，就说该接口跨域了。
跨域限制的原因：浏览器为了保证网页的安全，出的同源协议策略。
    1cors：目前最常用的一种解决办法，通过设置后端允许跨域实现。
    res.setHeader('Access-Control-Allow-Origin', '*');
    res.setHeader("Access-Control-Allow-Methods", "GET, PUT, OPTIONS, POST");

node中间件、nginx反向代理：跨域限制的时候浏览器不能跨域访问服务器，node中间件和nginx反向代理，都是让请求发给代理服务器，静态页面面和代理服务器是同源的，然后代理服务器再向后端服务器发请求，服务器和服务器之间不存在同源限制。
我们公司用的是proxy
客户端发送请求，先经过中间层的处理，将域名 http://localhost:8080 转换为 http://example.com
利用转换后的域名发送请求到server
服务端接收到请求的域名 http://example.com，相应经过中间层的处理，将域名进行转换，发送响应数据给客户端
client 收到和自己相同的域名，继续下一步操作
跨域场景：前后端分离式开发、调用第三方接口

6BFC
定义：块级格式上下文  **里面的布局不会影响外部** 特点：是一个独立的容器，内部的元素和外部元素互不影响。 形成：根元素、float、position不为relative、display不为none、overflow。 解决的问题：清除浮动、解决塌陷问题
【什么情况下可以让元素产生BFC】
1、float属性不为none
2、position为absolute或fixed
3、display为inline-block、table-cell、table-caption、flex、inline-flex
4、overflow不为visible
【BFC元素具有的特性】
1、在BFC中，盒子从顶部开始垂直地一个接一个排列
2、盒子垂直方向的距离由margin决定。同一个BFC的两个相邻盒子margin会重叠
3、BFC中，margin-left会触碰到border-left（对于从左至右的方式，反之）
4、BFC区域不会与浮动的盒子产生交集，而是紧贴边缘浮动
5、计算BFC高度时，自然会检测浮动的盒子高度
【主要用途】
1、清除内部浮动，父元素设置为BFC可以清除子元素的浮动（最常用overflow:hidden，IE6需加上*zoom:1）：计算BFC高度时会检测浮动子盒子高度
2、解决外边距合并问题
3、右侧盒子自适应：BFC区域不会与浮动盒子产生交集，而是紧贴浮动边缘

我们可以通过 box-sizing 修改盒模型，box-sizing border-box content-box
1 清除浮动啊  左边顶宽 右边自适应 下外边距的折叠 放在不同BFC
7 说一说JavaScript有几种方法判断变量的类型？
 typeof、instanceof、Object.prototype.toString.call()（对象原型链判断方法）、 constructor (用于引用数据类型) 
typeof：常用于判断基本数据类型，对于引用数据类型除了function返回’function‘，其余全部返回’object'。 instanceof：主要用于区分引用数据类型，a instanceof Object   instanceof运算符用于检测对象的原型链上是否存在构造函数的 prototype属性，有则返回 true，否则返回 false   ，除了函数基本数据类型以及 null 直接返回 false，不太适合用于简单数据类型的检测，检测过程繁琐且对于简单数据类型中的undefined, null, symbol检测不出来。 constructor：构造函数的属性 undefined和null特殊值不能用a. constructor用于检测引用数据类型，检测方法是获取实例的构造函数判断和某个类是否相同，如果相同就说明该数据是符合那个数据类型的，这种方法不会把原型链上的其他类也加入进来，避免了原型链的干扰。 Object.prototype.toString.call()：适用于所有类型的判断检测，检测方法是Object.prototype.toString.call(数据) 返回的是该数据类型的字符串。 这四种判断数据类型的方法中，各种数据类型都能检测且检测精准的就是Object.prototype.toString.call()这种方法。 加分回答 instanceof的实现原理：验证当前类的原型prototype是否会出现在实例的原型链__proto__上，只要在它的原型链上，则结果都为true。因此，`instanceof` 在查找的过程中会遍历左边变量的原型链，直到找到右边变量的 `prototype`，找到返回true，未找到返回false。 Object.prototype.toString.call()原理：Object.prototype.toString 表示一个返回对象类型的字符串，call()方法可以改变this的指向，那么把Object.prototype.toString()方法指向不同的数据类型上面，返回不同的结果5 jq中判断数据类型的方法 jQuery.isArray();jQuery.isFunction():是否为函数

8说一说样式优先级的规则是什么？
伪对象选择器>!important>行内样式>id选择器>class选择器>标签选择器>通配选择器>继承
-第一类`!important`，无论引入方式是什么，选择器是什么，它的优先级都是最高的。 -第二类引入方式，行内样式的优先级要高于嵌入和外链，嵌入和外链如果使用的选择器相同就看他们在页面中插入的顺序，在后面插入的会覆盖前面的。 -第三类选择器，选择器优先级：id选择器>（类选择器 | 伪类选择器 | 属性选择器 ）> （后代选择器 | 伪元素选择器 ）> （子选择器 | 相邻选择器） > 通配符选择器 。 -第四类继承样式，是所有样式中优先级比较低的。 -第五类浏览器默认样式优先级最低。 加分回答 使用!important要谨慎 - 一定要优先考虑使用样式规则的优先级来解决问题而不是 `!important` - 只有在需要覆盖全站或外部 CSS 的特定页面中使用 `!important` - 永远不要在你的插件中使用 `!important` - 永远不要在全站范围的 CSS 代码中使用 `!important` 优先级的比较指的是相同的样式属性，不同样式属性优先级比较失效，比如：在设置`max-width`时注意，已经给元素的`max-width`设置了`!important`但是还不生效，很有可能就是被width覆盖了 举例：`div`最终的宽度还是`200px` div { max-width: 400px !important; height: 200px;background-color: tomato; width: 200px; }

9 js 实现异步的方法
所有异步任务都是在同步任务执行结束之后，从任务队列中依次取出执行。 回调函数是异步操作最基本的方法，比如AJAX回调，回调函数的优点是简单、容易理解和实现，缺点是不利于代码的阅读和维护，各个部分之间高度耦合，使得程序结构混乱、流程难以追踪（尤其是多个回调函数嵌套的情况），而且每个任务只能指定一个回调函数。此外它不能使用 try catch 捕获错误，不能直接 return Promise包装了一个异步调用并生成一个Promise实例，当异步调用返回的时候根据调用的结果分别调用实例化时传入的resolve 和 reject方法，then接收到对应的数据，做出相应的处理。Promise不仅能够捕获错误，而且也很好地解决了回调地狱的问题，缺点是无法取消 Promise，错误需要通过回调函数捕获。 Generator 函数是 ES6 提供的一种异步编程解决方案，Generator 函数是一个状态机，封装了多个内部状态，可暂停函数, yield可暂停，next方法可启动，每次返回的是yield后的表达式结果。优点是异步语义清晰，缺点是手动迭代`Generator` 函数很麻烦，实现逻辑有点绕 async/awt是基于Promise实现的，async/awt使得异步代码看起来像同步代码，所以优点是，使用方法清晰明了，缺点是awt 将异步代码改造成了同步代码，如果多个异步代码没有依赖性却使用了 awt 会导致性能上的降低，代码没有依赖性的话，完全可以使用 Promise.all 的方式。 加分回答 JS 异步编程进化史：callback -> promise -> generator/yield -> async/awt。 async/awt函数对 Generator 函数的改进，体现在以下三点： - 内置执行器。 Generator 函数的执行必须靠执行器，而 async 函数自带执行器。也就是说，async 函数的执行，与普通函数一模一样，只要一行。 - 更广的适用性。 yield 命令后面只能是 Thunk 函数或 Promise 对象，而 async 函数的 awt 命令后面，可以跟 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。 - 更好的语义。 async 和 awt，比起星号和 yield，语义更清楚了。async 表示函数里有异步操作，awt 表示紧跟在后面的表达式需要等待结果。 目前使用很广泛的就是promise和async/awt

10 数组去重方法
第一种方法：利用对象属性key排除重复项：遍历数组，每次判断对象中是否存在该属性，不存在就存储在新数组中，并且把数组元素作为key，设置一个值，存储在对象中，最后返回新数组。这个方法的优点是效率较高，缺点是占用了较多空间，使用的额外空间有一个查询对象和一个新的数组

function duplicateRemoval(arr) {
	//定义接收去重后结果的新数组
    let newArr = [];
    for(let i = 0;i<arr.length;i++){
    	//判断新数组中是否存在当前索引为i的原数组元素
        if (!newArr.includes(arr[i])) {
        	//如果不存在，则将其放到新数组的最后位置
            newArr.push(arr[i]);
        }
    }
    //返回去重后的新数组
    return newArr;
} 

第二种方法：利用Set类型数据无重复项：new 一个 Set，参数为需要去重的数组，Set 会自动删除重复的元素，再将 Set 转为数组返回。这个方法的优点是效率更高，代码简单，思路清晰，缺点是可能会有兼容性问题 
第三种方法：filter+indexof 去重：这个方法和第一种方法类似，利用 Array 自带的 filter 方法，返回 arr.indexOf(num) 等于 index 的num。原理就是 indexOf 会返回最先找到的数字的索引，假设数组是 [1, 1]，在对第二个1使用 indexOf 方法时，返回的是第一个1的索引0。这个方法的优点是可以在去重的时候插入对元素的操作，可拓展性强。

 var newArr = arr.filter(function(item,index){
     return arr.indexOf(item) === index;  // 因为indexOf 只能查找到第一个  
  });

 第四种方法：这个方法比较巧妙，从头遍历数组，如果元素在前面出现过，则将当前元素挪到最后面，继续遍历，直到遍历完所有元素，之后将那些被挪到后面的元素抛弃。这个方法因为是直接操作数组，占用内存较少。
  第五种方法：reduce +includes去重：这个方法就是利用reduce遍历和传入一个空数组作为去重后的新数组，然后内部判断新数组中是否存在当前遍历的元素，不存在就插入到新数组中。这种方法时间消耗多，内存空间也有额外占用。 方法还有很多，常用的、了解的这些就可以 加分回答 以上五个方法中，在数据低于10000条的时候没有明显的差别，高于10000条，第一种和第二种的时间消耗最少，后面三种时间消耗依次增加，由于第一种内存空间消耗比较多，且现在很多项目不再考虑低版本浏览器的兼容性问题，所以建议使用第二种去重方法，简洁方便。

let arr = [1, 2, 2, 4, null, null].reduce((accumulator, current) => {
    return accumulator.includes(current) ? accumulator : accumulator.concat(current);
}, []); 

11 复杂数据类型判断
https://blog.csdn.net/weixin_43797046/article/details/107673635?ops_request_misc=&request_id=&biz_id=102&utm_term=js%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E7%9B%B8%E7%AD%89&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-107673635.nonecase&spm=1018.2226.3001.4187

12null 和 undefined 的区别，如何让一个属性变为null
undefined == null、undefined !== null 标准回答 undefind 是全局对象的一个属性，当一个变量没有被赋值或者一个函数没有返回值或者某个对象不存在某个属性却去访问或者函数定义了形参但没有传递实参，这时候都是undefined。undefined通过typeof判断类型是'undefined'。undefined == undefined undefined === undefined 。 null代表对象的值未设置，相当于一个对象没有设置指针地址就是null。null通过typeof判断类型是'object'。null === null null == null null == undefined null !== undefined undefined 表示一个变量初始状态值，而 null 则表示一个变量被人为的设置为空对象，而不是原始状态。在实际使用过程中，不需要对一个变量显式的赋值 undefined，当需要释放一个对象时，直接赋值为 null 即可。 让一个变量为null，直接给该变量赋值为null即可。 加分回答 null 其实属于自己的类型 Null，而不属于Object类型，typeof 之所以会判定为 Object 类型，是因为JavaScript 数据类型在底层都是以二进制的形式表示的，二进制的前三位为 0 会被 typeof 判断为对象类型，而 null 的二进制位恰好都是 0 ，因此，null 被误判断为 Object 类型。 对象被赋值了null 以后，对象对应的堆内存中的值就是游离状态了，GC 会择机回收该值并释放内存。因此，需要释放某个对象，就将变量设置为 null，即表示该对象已经被清空，目前无效状态。

13说一下浮动？
脱离文档流、盒子塌陷、 影响其他元素排版、伪元素 、`overflow:hidden` 、标签插入法 标准回答 浮动的作用，设置浮动的图片，可以实现文字环绕图片，设置了浮动的块级元素可以排列在同一行，设置了浮动的行内元素可以设置宽高，同时可以按照浮动设置的方向对齐排列盒子。 设置浮动元素的特点： -设置了浮动，该元素脱标。元素不占位置 -浮动可以进行模式转换（行内块元素） 浮动造成的影响，使盒子脱离文档流，如果父级盒子没有设置高度，需要被子盒子撑开，那么这时候父级盒子的高度就塌陷了，同时也会造成父级盒子后面的兄弟盒子布局受到影响。如果浮动元素后面还有其他兄弟元素，其他兄弟元素的布局也会受到影响。 清除浮动的方法： -伪元素清除浮动：给浮动元素父级增加 .clearfix::after { content: ''; display: table; clear: both; } /*兼容IE低版本 */ .clearfix { *zoom: 1; } overflow：hidden`：给浮动元素父级增加`overflow：hidden`属性 额外标签法：给浮动元素父级增加标签
加分回答 三种清除浮动的特点和影响 -伪元素清除浮动：不会新增标签，不会有其他影响，是当下清除浮动最流行的方法 -`overflow：hidden`：不会新增标签，但是如果父级元素有定位元素超出父级，超出部分会隐藏，在不涉及父级元素有超出内容的情况，overflow：hidden比较常用，毕竟写法方便简洁 -标签插入法：清除浮动的语法加在新增标签上，由于新增标签会造成不必要的渲染，所以这种方法目前不建议使用

14 说一说es6中箭头函数？
箭头函数有两种写法，当函数体是单条语句的时候可以省略{}和return。另一种是包含多条语句，不可以省略{}和return。
 箭头函数最大的特点就是没有this，所以this是从外部获取就是继承外部的执行上下文中的this，由于没有this关键字所以箭头函数也不能作为构造函数， 同时通过 call() 或 apply() 方法调用一个函数时，只能传递参数（不能绑定this），第一个参数会被忽略。
箭头函数也没有原型和super。不能使用yield关键字，因此箭头函数不能用作 Generator 函数。不能返回直接对象字面量。 加分回答 箭头函数的不适用场景： -定义对象上的方法 当调用 dog.jumps 时，lives 并没有递减。因为 this 没有绑定值，而继承父级作用域。 var dog = { lives: 20, jumps: () => { this.lives--; } } -不适合做事件处理程序 此时触发点击事件，this不是button，无法进行class切换 var button = document.querySelector('button'); button.addEventListener('click', () => { this.classList.toggle('on'); }); 箭头函数函数适用场景： -简单的函数表达式，内部没有this引用，没有递归、事件绑定、解绑定，适用于map、filter等方法中，写法简洁 var arr = [1,2,3]; var newArr = arr.map((num)=>num*num) -内层函数表达式，需要调用this，且this应与外层函数一致时 let group = { title: "Our Group", students: ["John", "Pete", "Alice"], showList() { this.students.forEach( student => alert(this.title + ': ' + student) ); } }; group.showList();
1.写法简洁 2.无自己的this，继承上一个作用域的this（全局或上一个函数） 3.内部this无法被改变 4.arguments的特殊性（window下保存，this指向上一个函数则arguments表示上一个函数的参数） 5.不能作为构造函数（无自己的this、constructor） 6.无自己的prototype
15 call apply bind的作用和区别？
function.call(thisArg, arg1, arg2, ...)
function.apply(thisArg, [arg1, arg2, ...])
fucntion.bind(thisArg, arg1, arg2, ...)
首先，call apply bind三个方法都可以用来改变函数的this指向，具体区别如下：
1、fn.call (newThis,params) call函数的第一个参数是this的新指向，后面依次传入函数fn要用到的参数。会立即执行fn函数。
2、fn.apply (newThis,paramsArr) apply函数的第一个参数是this的新指向,第二个参数是fn要用到的参数数组，会立即执行fn函数。
3、fn.bind (newThis,params) bind函数的第一个参数是this的新指向，后面依次传入函数fn要用到的参数。  不会立即执行fn函数，且只能改变一次fn函数的指向，后续再用bind更改无效。
16 .什么是深拷贝和浅拷贝?以及怎么实现深拷贝和浅拷贝?
在大部分编程语言中，变量会被存放在两个地方，栈（stack）和堆（heap）。在 JavaScript 中栈存放的就是值类型的数据和引用类型的地址，而引用类型真正的数据被存放在堆中。
浅拷贝是创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。
深拷贝是将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象。
lodash  deepclone 深拷贝JSON.parse(JSON.stringify())    浅拷贝 _.clone 展开运算符 对象合并 concat  
手写一个深拷贝  hasOwnProperty判断是否有自己的属性
function deepClone(obj) {
    if (typeof obj != 'object') return obj;
    var temp = Array.isArray(obj) ? [] : {};
    for (let key in obj) {
        if (obj.hasOwnProperty(key)) {
            if (obj[key] && typeof obj[key] == 'object') { // 如果obj[key]还是对象则执行递归
                temp[key] = deepClone(obj[key]); // 递归
            } else {
                temp[key] = obj[key];
            }
        }
    }
    return temp;
}

17 .  浏览器的垃圾回收机制  GC
垃圾回收是指 JavaScript代码运行时，需要分配内存空间来储存变量和值。当变量不在参与运行时，就需要系统收回被占用的内存空间。 
Memory 堆快照检测内存
1 内存管理机制  
    分配所需要的系统内存空间；
    使用分配到的内存进行读或写等操作；
    不需要使用内存时，将其空间释放或者归还。
    例子（比如说创建变量 系统发现变量不再使用，系统会通过垃圾回收机制的方式来处理掉这些变量所占用的内存）
    基础数据类型保存在 栈中  引用数据类型 内存地址存在栈中 指向堆中的对象
    1 比如说变量 分为全局变量和局部变量。全局变量的生命周期会持续要页面卸载；而局部变量声明在函数中，它的生命周期从函数执行开始，直到函数执行结束，在这个过程中，局部变量会在堆或栈中存储它们的值，当函数执行结束后，这些局部变量不再被使用，它们所占有的空间就会被释放。不过，当局部变量被外部函数使用时，其中一种情况就是闭包，在函数执行结束后，函数外部的变量依然指向函数内部的局部变量，此时局部变量依然在被使用，所以不会回收。

谷歌垃圾回收机制
1 遍历 GC Root 中所有对象：区分不可访问活动 对象（可回收）和可访问活动对象（保留内存）GC Root => window 对象  DOM树 栈变量
2 第⼆步，回收⾮活动对象所占据的内存 统⼀清理内存中所有被标记为可回收的对象
3 第三步 内存整理  频繁回收导致出现大量内存碎片 需要回收 
避免垃圾回收方法 1 对象不用设置null 2数组清空 length=0 3函数多复用

18  . 内存泄露与优化
v-if 导致的内存泄露 实际上 dom 元素在隐藏的时候没有被真实的释放掉  一直在创建 大屏放了几天崩了 。 我们可以用 hide() 方法在将选择框从 DOM 中移除之前做一些清理工作，来解决内存泄露问题。
实时监测档案 接收 转入导出 一个系统大屏 采用定时器轮询请求的方式 同时 四个页面的 每隔20秒有一个转换  。客户端开发完成后交付现场部署使用，已经部署过几个现场。据反馈，在实际使用过程中，存在页面卡顿问题，但关掉客户端重启就会好点，并不会影响业主的使用，因而没有得到过多的关注。 但是是因为大屏一直在运行会导致网页崩溃。
和其他现场对比客户端环境，发现该现场内存过小，因此提议先增加内存观察。内存扩大一倍，发现系统仍然会卡死，只是到达卡死的时间会长点。推测存在内存泄露问题。
看代码 第一时间想到是V-IF 导致内存暴露。根据上面的分析对相应代码进行了修改，原以为问题得到解决了。。结果发现虽然页面没有很快卡死，但是内存占用在逐步上升。客户端放在现场不进行任何操作，只是不断地有实施告警弹窗弹出，放置一夜后发现内存的占比竟然增加了好多。而且发现一旦进行页面操作，内存会持续上升不会释放，终于在我不断的页面操作下，系统在又放置了一夜后，终于因内存溢出而卡死了。。原本以为可以很愉快的度过一个周末的，结果现在整个人都不好了。。这下真的是内存泄露的。。芭比Q了。。
由于 electron 内置的是 chrome 的浏览器内核，我们可以直接在系统中调用谷歌浏览器的开发者工具中 performance 来监控 通过上面的监控效果来看，很明显的存在内存泄露。  继续往下研究。。。不断的换思路，不断的换查看方式。。最终发现了下面的问题。。使用谷歌浏览器中的开发者工具中 memory 来分析。闭包分类直指2第三方库！  发现是和echars 还有流程图的一个第三方组件 。 还有一个就是这个里面怎么有个定时器！！而且这个定时还不会被销毁！实时他的做法用定时器几秒一次调用。定时器里面还引用了外部变量！每一次数据服务都会创建实例，这样的话每次实例都会创建一个不会被销毁的的定时器，每个实例都会引用同一个外部变量！！！这样每次数据请求完，这个实例都不可能会被垃圾回收掉！!  以为好了 但结果放了一夜 页面还是变卡了 一查内存还在泄露。memory中蓝色的柱子线表明这块的创建的东西一直得不到回收！！然后点击对应的 Object 看发现全部指向第三方库的这个变量。。。又赶紧去看对应的文件。 。每一次调用数据服务创建的实例对象都会给这个变量对象添加属性，久而久之，这个变量会越来越大，越来越夸张。。而且由于这个对象一直被引用着，那么当初创建他的实例也一直得不到释放。。
内存泄漏是指在 JavaScript 中，已经分配堆内存地址的对象由于长时间未释放或者无法释放，造成了长期占用内存，使内存浪费，最终会导致运行的应用响应速度变慢以及最终崩溃的情况。这种就是内存泄漏，在日常开发和使用浏览器过程中内存泄漏的场景：
过多的缓存未释放；
闭包太多未释放；
定时器或者回调太多未释放；
太多无效的 DOM 未释放；
全局变量太多未被发现。
1在使用完数据后，及时解除引用（闭包中的变量，DOM 引用，定时器清除）。
2组织好代码逻辑，避免死循环等造成浏览器卡顿、崩溃的问题。
3避免不合理的使用闭包，从而导致某些变量一直被留在内存当中。

19   什么是原型和原型链
原型  

原型通常指的是prototype和__proto__这两个原型对象
其中前者叫做显式原型对象,后者叫做隐式原型对象
在js中所有的函数都有一个prototype对象,每一个对象都有__proto__,既然prototype是一个对象,那么他必然也有一个__proto__(在后面会详细解释)
    1.所有引用类型都有一个__proto__(隐式原型)属性，属性值是一个普通的对象
    2.所有函数都有一个prototype(原型)属性，属性值是一个普通的对
    3.所有引用类型的__proto__属性指向它构造函数的prototype  
        var a = [1,2,3];
        a.__proto__ === Array.prototype;

1.原型对象：
在我们创建函数或者构造函数的时候，都会自动添加一个属性prototype 也就是我们所说的原型对象。
原型链
当访问一个对象的某个属性时，会先在这个对象本身属性上查找，如果没有找到，则会去它的__proto__隐式原型上查找，即它的构造函数的prototype，如果还没有找到就会再在构造函数的prototype的__proto__中查找，这样一层一层向上查找就会形成一个链式结构，我们称为原型链。
20    js 六种继承方式介绍和缺点 www.cnblogs.com/wrhbk/p/144…
1原型链继承
    Parent 中的引用属性会被每个子类示例共享  自己创造构造函数 实例对象 共享构造函数的方法属性
       某个构造函数的prototype指向另一个构造函数

//原型链继承
 2         function Parent() {
 3             this.parentPrototype = "parent prototype"
 4             //验证这种继承方法的确定，如果父类示例中存在一个引用类型的属性，将会被所有子类共享
 5             this.parentObj = {
 6                 info: "我是 parent 引用属性parentObj中的 info"
 7             }
 8         }
 9 
10         function Children() {
11 
12         }
13         //将Children的原型对象指定为Parent的示例，通过原型链，将Parent中的属性赋值给Children示例
14         Children.prototype = new Parent();
15         const a = new Children();
16         console.log(a.parentPrototype); // parent prototype
17         //缺点
18         const b = new Children();
19         //在a示例中改动继承的引用属性
20         a.parentObj.info = "我是a示例中 引用属性parentObj中的 info"
21         //b与a示例共享引用属性
22         console.log(b.parentObj.info); // 我是a示例中 引用属性parentObj中的 info

2 借用构造函数继承
盗用构造函数就是在子类构造函数中调用父类构造函数（在自己的构造函数中偷偷用父类的构造函数，所以是盗用） ，因此通过使用apply()和call()方法对象冒充继承也可以在新创建的对象上执行构造函数
　优点：
　　　　　　1避免了子类示例共享引用属性的情况
　　　　　　2可以在实例化时给Parent构造函数传递参数
　　　　缺点:
　　　　　　1如果Parent中存在一个函数，那么每次实例化Children的时候，都会创建一个同样函数，函数的复用性就难以体现
　　　　　　
function Box(name){
 this.name = name
}
Box.prototype.age = 18
 
function Desk(name){
 Box.call(this, name) // 对象冒充，对象冒充只能继承构造里的信息
}
 
var desk = new Desk('ccc')
console.log(desk.name)   // --> ccc
console.log(desk.age)    // --> undefined
  

3组合继承：原型链 + 构造函数 （这是js中最常见的继承方式）
　　　　优点：
　　　　　　1 避免了子类共享引用属性同时避免了父类构造函数重复对function属性的创建

function Box(name){
 this.name = name
}
Box.prototype.run = function (){
 console.log(this.name + '正在运行...')
}
 
function Desk(name){
 Box.call(this, name) // 对象冒充
}
 
Desk.prototype = new Box() // 原型链
 
var desk = new Desk('ccc')
console.log(desk.name)   // --> ccc
desk.run()         // --> ccc正在运行...    


4 原型式继承（注意：是原型式而非原型链，这种方法使用较少）    object()函数内部，先创建了一个临时性的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回了这个临时类型的一个新实例。从本质上讲，object()对传入其中的对象执行了一次浅复制。
 1          function objFn(o) {
 2                 o.objFnPrototype = "我是 objFnPrototype"
 3                 function F() {}
 4                 F.prototype = o;
 5                 return new F();
 6             }
 7 
 8             let a = objFn({
 9                 name: "name1"
10             });
11             console.log(a.name); //name1
12             console.log(a.objFnPrototype); //我是 objFnPrototype    

5寄生式继承（个人感觉就是定义了一个方法，复制了一个对象，让后在复制的对象上添加属性和方法，然后return）
　　　　缺点：
　　　　　　1和原型链继承一样，parent中的引用属性，会被所有示例共享
vue
  function createObje(obj) {
                let clone = Object.assign(obj); //接受到对象后，原封不动的创建一个新对象
                clone.prototype1 = "我是新增的prototype1"; //在新对象上新增属性，这就是所谓的寄生
                return clone; //返回新对象
            }
            const parent = {
                parentPrototype: "parentPrototype"
            }
            //c实例，就继承了parent的所有属性
            let c = createObje(parent);
            console.log(c.parentPrototype); //parentPrototype    

6寄生组合式继承 （寄生+组合（原型链+借用构造函数））
  function inherProto(superType, subType) {
 2                 //拷贝一个超类的原型副本
 3                 let proto = {
 4                     ...superType.prototype
 5                 };
 6                 //将原型的超类副本作为子类的原型对象，也就是第一种中的原型链继承方式，只不过继承的是超类原型的副本
 7                 subType.prototype = proto;
 8                 //这一步比较迷，官方的说法是，我们在拷贝超类的原型的时候，拷贝的proto对象，将会丢失默认自己的构造函数，也就是superType，
 9                 //所以我们这里将它的构造函数补全为subType。貌似不做这一步也没啥问题，但是缺了点东西可能会有其他的副作用，所以还是补上
10                 proto.constructor = subType;
11 
12             }
13 
14             function Super() {
15                 this.superProto = "super proto";
16                 this.colors = ["red", "yelloy"];
17             }
18 
19             function Sub() {
20                 this.subProto = "sub proto";
21                 this.name = "sub name";
22                 //这里还是借用构造函数的套路
23                 Super.call(this);
24             }
25             Super.prototype.getName = function () {
26                 console.log(this.name);
27             }
28             //这里要在定义完Super的属性后执行，因为继承的是超类原型的副本，与Super.prototype是两个对象，在这之后再改变Super.prototype，就已经不会在影响到Sub所继承的副本超类原型对象了
29             inherProto(Super, Sub);
30 
31             let a = new Sub();
32             console.log(a.getName);

21 css尺寸

px：绝对像素 2. rem：相对于根元素像素 3. em：相对于父元素像素 4. vw：视口宽度 5. vh：视口高度

em：相对长度单位，在 font-size 中使用是相对于父元素的字体大小，在其他属性中使用是相对于自身的字体大小，如 width。如当前元素的字体尺寸未设置，由于字体大小可继承的原因，可逐级向上查找，最终找不到则相对于浏览器默认字体大小。 rem：相对长度单位，相对于根元素的字体大小，根元素字体大小未设置，使用浏览器默认字体大小。 vw：相对长度单位，相对于视窗宽度的1%。 vh：相对长度单位，相对于视窗高度的1%。 加分回答
rem应用：在移动端网页开发中，页面要做成响应式的，可使用rem配合媒体查询或者flexible.js实现   。原理是通过媒体查询或者flexible.js，能够在屏幕尺寸发生改变时，重置html根元素的字体大小，页面中的元素都是使用rem为单位设置的尺寸，因此只要改变根元素字体大小，页面中的其他元素的尺寸就自动跟着修改 vw应用：由于vw被更多浏览器兼容之后，在做移动端响应式页面时，通常使用vw配合rem。原理是使用vw设置根元素html字体的大小，当窗口大小发生改变，vw代表的尺寸随着修改，无需加入媒体查询和flexible.js，页面中的其他元素仍使用rem为单位，就可实现响应式。
22 移动端适配  （用户改变字体大小）
本质还是rem适配
1 媒体查询PC  不同的移动端尺寸设置不同的 html 字体大小


@media screen and (min-width:321px) and (max-width:375px)
{html{font-size:11px}}

postcss-pxtorem   将项目中的px 自动转换成rem 同时设置基准大小 页面根节点字体大小

html {
font-size: 35px;

}  此时1rem=35px
还有一种做法
类似于lib-flexible  /10

比如说flexible   750PX宽 手机 75px 1rem    postcss    也需要设置/75

 //rem适配
 (function () {
        var  styleN = document.createElement("style");
        var width = document.documentElement.clientWidth/16;
        styleN.innerHTML = 'html{font-size:'+width+'px!important}';
        document.head.appendChild(styleN);


amfe-flexible是按照屏幕宽度的十分之一来设置font-size的，所以我们remUnit的大小设置也应该是设计稿宽度的十分之一,这样css样式才会和设计稿一样.  比如设计稿750   1rem=75px
postcss     将所有css 的px 转换rem  转换比需要设置 一般来说要与flexible 一致  但是需要适配第三方ui组件 可以使用动态对象 三元判断下 传参是不是来源node 第三方组件
2者结合 适配第三方组件的方法    首先知道第三方组件的rootValue  通过postcss unit 动态设置他的px=>rem的比例
21 html5 css3 新特性
html5
语义化标签， header, footer, nav, aside,article,section
增强型表单
视频 video 和音频 audio
Canvas 绘图
SVG绘图
地理定位
拖放 API
WebWorker
WebStorage( 本地离线存储 localStorage、sessionStorage )
WebSocket
css3
1、颜色：新增RGBA、HSLA模式
2、文字阴影：（text-shadow）
3、边框：圆角（border-radius）边框阴影：box-shadow
4、盒子模型：box-sizing
5、背景：background-size,background-origin background-clip(削弱)
6、渐变：linear-gradient(线性渐变):
eg: background-image: linear-gradient(100deg, #237b9f, #f2febd);
radial-gradient (径向渐变)
7、过渡：transition可实现动画
8、自定义动画： animate@keyfrom
9、媒体查询：多栏布局@media screen and (width:800px)
10、border-image
11、2D转换:transform:translate(x,y) rotate(x,y)旋转 skew(x,y)倾斜 scale(x,y)缩放
12、3D转换
13、字体图标：Font-Face
14、弹性布局：flex
如样式A设置 transition： transform 0.5s ； transform-arigin：50% 25%
B的 hover .A中设置 transform：rate（180dap）
22 垂直居中
23DOM 事件机制/模型
就比如用户触发一个点击事件，有一个触发的过程
事件捕获-阶段（从上大小，从外到内）--->处于目标事件-阶段---->事件冒泡-阶段（从下到上，从内到外）
window.addEventListener(
  "click",
  function (event) {
    event = event || window.event /*ie*/;

    const target = event.target || event.srcElement; /*ie*/ // 拿到事件目标

    // 阻止冒泡
    // event.stopPropagation()
    // event.cancelBubble=true; // ie

    // 阻止默认事件
    // event.preventDefault();  提交按钮 阻止提交事件 或者a链接组织跳转
    // event.returnValue=false; // ie
  },
  /* 是否使用捕获，默认是fasle, */ fasle
);

事件委托
简介：事件委托指的是，不在事件的发生地（直接 dom）上设置监听函数，而是
在其父元素上设置监听函数，通过事件冒泡，父元素可以监听到子元素上事件的
触发，通过判断事件发生元素 DOM 的类型，来做出不同的响应。
举例：最经典的就是 ul 和 li 标签的事件监听，比如我们在添加事件时候，采用
事件委托机制，不会在 li 标签上直接添加，而是在 ul 父元素上添加。
好处：比较合适动态元素的绑定，新添加的子元素也会有监听函数，也可以有事
件触发机制
24CommonJS 与 ES6 Module 的差异
CommonJS 与 ES6 Module 的差异
CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。
var counter = 3;
function incCounter() {
  counter++;
}
module.exports = {
  counter: counter,
  incCounter: incCounter,
};
// main.js
var mod = require('./lib');

console.log(mod.counter);  // 3
mod.incCounter();
console.log(mod.counter); // 3

// lib.js
export let counter = 3;
export function incCounter() {
  counter++;
}

// main.js
import { counter, incCounter } from './lib';
console.log(counter); // 3
incCounter();
console.log(counter); // 4

CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。
ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的import有点像 Unix 系统的“符号连接”，原始值变了，import加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。
CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。
运行时加载: CommonJS 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。
编译时加载: ES6 模块不是对象，而是通过 export 命令显式指定输出的代码，import时采用静态命令的形式。即在import时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。
CommonJS 加载的是一个对象（即 module.exports 属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。
25 defer和async区别？
html文件都是按顺序执行的，script标签中没有加defer和async时，浏览器会立即加载并执行指定的脚本，“立即”指的是在渲染该 script 标签之下的文档元素之前，也就是说不等待后续载入的文档元素，读到就加载并执行。。 而在script标签中写入defer或者async时，就会使JS文件异步加载，即html执行到script标签时，JS加载和文档解析同时进行，而async是在JS加载完成后立即执行JS脚本，阻塞文档解析，而defer则是JS加载完成后，在文档解析完成后执行JS脚本
有 async，加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行（异步）。
有 defer，加载后续文档元素的过程将和 script.js 的加载并行进行（异步），但是 script.js 的执行要在所有元素解析完成之后，DOMContentLoaded事件触发之前完成。
defer与async的区别是：前者要等到整个页面正常渲染结束，才会执行；后者一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。一句话，defer是“渲染完再执行”，async是“下载完就执行”。另外，如果有多个defer脚本，会按照它们在页面出现的顺序加载，而多个async脚本是不能保证加载顺序的。
defer
如果你的脚本代码依赖于页面中的DOM元素（文档是否解析完毕），或者被其他脚本文件依赖。
评论框
代码语法高亮
polyfill.js
async
如果你的脚本并不关心页面中的DOM元素（文档是否解析完毕），并且也不会产生其他脚本需要的数据。
26ES6
新增 Symbol 类型 表示独一无二的值，用来定义独一无二的对象属性名;
const/let 都是用来声明变量,不可重复声明，具有块级作用域。存在暂时性死区，不存在变量提升。(const 一般用于声明常量);
变量的解构赋值(包含数组、对象、字符串、数字及布尔值,函数参数),剩余运算符(...rest);
模板字符串(${data});
...扩展运算符(数组、对象);;
箭头函数;
Set 和 Map 数据结构;
Proxy/Reflect;
Promise;
async 函数;
Class;
Module 语法(import/export)。
27行内元素、块级元素、 空元素有那些？
行内元素 (不能设置宽高，设置宽高无效) a,span,i,em,strong,label
行内块元素：img, input
块元素： div, p, h1-h6, ul,li,ol,dl,table…
知名的空元素 br, hr,img, input,link,meta
28setTimeout、setInterval 和 requestAnimationFrame(跟随浏览器的重绘)之间的区别\
requestAnimationFrame 不需要设置时间  requestAnimationFrame 会把每一帧中的所有 DOM 操作集中起来，在一次 重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率 每秒调用60次， 大约16.7ms
setTimeout()用于在指定的毫秒数后调用函数或计算表达式
setInterval()在播放动画的时，每隔一定时间就调用函数，方法或对象
（1）requestAnimationFrame 会把每一帧中的所有 DOM 操作集中起来，在一次 重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率。
（2）在隐藏或不可见的元素中，requestAnimationFrame 将不会进行重绘或回 流，这当然就意味着更少的 CPU、GPU 和内存使用量
（3）requestAnimationFrame 是由浏览器专门为动画提供的 API，在运行时浏览 器会自动优化方法的调用，并且如果页面不是激活状态下的话，动画会自动暂停， 有效节省了 CPU 开销。
cancelAnimationFrame()
29、什么是防抖和节流？有什么区别？如何实现？
loadsh
_.debounce(func, [wait=0], [options={}])防抖
_.throttle(func, [wait=0], [options={}]) 节流
防抖
触发高频事件后n秒内函数只会执行一次，如果n秒内高频事件再次被触发，则重新计算时间
频繁操作点赞和取消点赞，因此需要获取最后一次操作结果并发送给服务器；search搜索联想，用户在不断输入值时…
const debounce=(fn, delay) => {
    //记录上一次的延时器
    let timer = null;
    return () => {
        //清除上一次延时器
        clearTimeout(timer);
        //重新设置新的延时器
        timer = setTimeout(() => {
            fn()
        }, delay)
    }
};
 

节流：
一般是onrize，onscroll等这些频繁触发的函数，比如你想获取滚动条的位置，然后执行下一步动作；鼠标不断点击触发，mousedown(单位时间内只触发一次)…
比如你想获取滚动条的位置，然后执行下一步动作。如果监听后执行的是Dom操作，这样的频繁触发执行，可能会影响到浏览器性能，甚至会将浏览器卡崩。
我们可以规定他多少秒执行一次，这种方法叫函数节流
 const throttle=(fn, delay) => {
    //记录上一次函数触发的时间
    let lastTime = 0;
    return () => {
        //记录当前函数触发的时间
        let nowTime = Date.now();
        if (nowTime - lastTime > delay) {
            fn();
            //同步时间
            lastTime = nowTime;
        }
    }
}; 

30 webpack 面试题
    process.env.NODE_ENV === 'production'  判断是不是生产环境

1 打包优化 分析  speed-measure-webpack-plugin
它分析 webpack 的总打包耗时以及每个 plugin 和 loader 的打包耗时，从而让我们对打包时间较长的部分进行针对性优化。
2 分包 一些CDN 排除打包列表
可以通过 cdn 的形式引入它们，然后将 react、react-dom 从打包列表中排除，这样可以减少打包所需的时间
1 html-webpack-externals-plugin
2  部分webpack 框架  externals  将输入 entre 定位指定的CDN
3  核心 打包体积优化   可以借助一些可视化工具
以下是代码拆分
	***提取公共模块*** 
		optimization属性中：splitChunks  提取公共模块 下面的cacheGroups 再可以提取第三方组件
1） splitChunks  设置这个值会自动提取所有公共模块  （或者配置 异步加载的 或者同步的 一般默认用async  异步 就是import 进入的）
		如chunks 选项，决定要提取哪些模块
        1、默认是 async ：只提取异步加载的模块出来打包到一个文件中。
         异步加载的模块：通过 import(‘xxx’) 或 require([‘xxx’],() =>{}) 加载的模块。
        2、initial：只对入口chunk生效；
        3、all：不管异步加载还是同步加载的模块都提取出来，打包到一个文件中；	
2)splitChunks   中的核心acheGroups 选项，核心重点，配置提取模块的方案，里面   每一项代表一个提取模块的方案。
下面是 cacheGroups 每项中特有的选项，其余选项和外面一致，若 cacheGroups 每项中有，就按配置的，没有就使用外面配置的；  

以下是 加载器 loader
webpack 自身只能解读 JavaScript，对其进行文件的合并、压缩处理。但是我们实际项目中会用到很多类型的文件，如 css、less、jpg、jsx、vue 等等，webpack 本身是处理不了它们的，这个时候就要借助于各种 loader。
webpack 常用 loader，plugin
loader
post-loader px转rem
babel-loader 将 es6 转换成 es5 , ts-loader、vue-loader  缓存babel的编译结果
eslint-loader 配置 enforce: 'pre' 这个 loader 最先执行
css-loader、style-loader、postcss-loader、less-loader、sass-loader
file-loader 把文件转换成路径引入, url-loader（比file-loader多了小于多少的能转换成 base64）
image-loader
svg-sprite-loader 处理 svg
thread-loader 开启多进程 ，会在一个单独的 worker 池（worker pool）中运行
cache-loader 缓存一些性能开销比较大的 loader 的处理结果
以下是 插件plugin
插件是用来处理各种任务的，比如代码的压缩，打包优化，等等。比如自动生成 html 文件的插件
webpack.HotModuleReplacementPlugin 热更新 （                    1
保留在完全重新加载页面时丢失的应用程序的状态。
只更新改变的内容，以节省开发时间。
调整样式更加快速，几乎等同于就在浏览器调试器中更改样式。）
terser-webpack-plugin 压缩 js， 可开启多进程压缩、推荐使用     排除console.log（）*1
HardSourceWebpackPlugin 缓存(第二次 加载会快很多) *1
mini-css-extract-plugin 提取 CSS 到独立 bundle 文件。 extract-text-webpack-plugin *1
optimize-css-assets-webpack-plugin 压缩 css webpack5 推荐css-minimizer-webpack-plugin *1
html-webpack-plugin 将生成的 css，js 自动注入到 html 文件中，能对 html 文件压缩
copy-webpack-plugin 拷贝某个目录
clean-webpack-plugin 清空某个目录
webpack.DefinePlugin 定义全局变量
purgecss-webpack-plugin 会单独提取 CSS 并清除用不到的 CSS（会有问题把有用的 css 删除）
speed-measure-webpack-plugin 打包构建速度分析、查看编译速度 *1
webpack-bundle-analyzer 打包体积分析 *1
compression-webpack-plugin gzip 压缩
以下是 入口
entry:["./src/index.js","./src/main.js"],
以下是 出口  多个出口 设置动态对象 对象名为入口名
“output”:{//输出的目录
filename:"[name].js",
path:resolve(__dirname,“build”)
}
31 说一下盒子模型
IE盒子模型的宽高包括content和padding还有border，标准盒子模型 不包括，
box-sizing:content-box 标准盒模型
box-sizing:border-box IE盒模型
32 垂直居中的方式
行高=高
Margin auto 0
绝对定位 top50%，自身宽度的50%的负值
flex布局 align---center
水平居中的方式
绝对定位
flex布局 juest---center
margin 0 auto
text-align center
32 、有哪些方式可以隐藏页面元素？区别?
display:none
visibility:hidden
opacity:0
设置height、width模型属性为0
position:absolute
clip-path

33如何解决数字精度丢失的问题?
理论上用有限的空间来存储无限的小数是不可能保证精确的，但我们可以处理一下得到我们期望的结果
当你拿到 1.4000000000000001 这样的数据要展示时，建议使用 toPrecision 凑整并 parseFloat 转成数字后再显示，如下：
parseFloat(1.4000000000000001.toPrecision(12)) === 1.4  // True
封装成方法就是：
function strip(num, precision = 12) {
return +parseFloat(num.toPrecision(precision));
}
最后还可以使用第三方库，如Math.js、BigDecimal.js
34 mvc和mvvc的区别
2： 传统的web开发时如何实现MVC模式的
如果前端没有框架，只使用原生的html+js，MVC模式可以这样理解。
将html看成view;
js看成controller，负责处理用户与应用的交互，响应对view的操作（对事件的监听），调用Model对数据进行操作，完成model与view的同步（根据model的改变，通过选择器对view进行操作）;
将js的ajax当做Model，也就是数据层，通过ajax从服务器获取数据（按照上面这种方式分层，感觉多少有点强行MVC，因为Model层被弱化了）。
MVVM    模型即视图 视图即模型。原来的js 是需要动态去绑定 onchange  M模型 V 视图 vm
View负责页面的显示逻辑；Model的数据同步到View显示出来，还负责把View的修改同步回Model。
Model负责存储页面的业务数据以及对相应数据的操作；
ViewModel使用了双向的数据绑定，
实现View与VM保持同步，
3：MVC模式有什么缺点
对 DOM 操作的代价非常高
程序运行缓慢且效率低下
内存浪费严重
应用程序复杂性高，难以分工开发。
vm是view mode的意思。所以mvvm框架是要有一个vm对象，来映射view。也就是vm对象的属性发生改变的时候，对应的视图部分会相对应更新。
双向数据
View 传送指令到 Controller Controller 完成业务逻辑后，要求 Model 改变状态 Model 将新的数据发送到 View，用户得到反馈
35 vue  react区别
vue  react区别
35  React类组件和函数组件之间有什么区别？
不同：
1、函数组件比类组件性能好
因为类组件使用过程中，需要实例化，而函数组件不需要
2、this？声明周期？state？
函数组件没有this，没有生命周期，没有状态state.
类组件有this，有生命周期，有状态state。
这也是有状态组件和无状态组件的区别。
Hook 函数式组件像类式组件一样拥有state、ref、生命周期等属性
1 useState
使函数式组件也能保存状态的一个hook，这个hook的入参是状态的初始值，返回值是一个数组，数组里第一个参数为状态的值，第二个参数为修改状态的方法。
2useEffect
函数式组件用来模拟生命周期的hook，可以模拟组件挂载完成、更新完成、即将卸载三个阶段，即componentDidMount、componentDidUpdate、componentWillUnmount。

useEffect(()=>{
  // 这样模拟的是 componentDidMount
}, [])
 
useEffect(()=>{
  // 这样模拟的是componentDidMount 以及当count发生变化时执行componentDidUpdate
}, [count])
 
useEffect(()=>{
  return ()=>{
  // 这样模拟的是 componentWillUnmount
  }
}, [])
 

3 useContext 获取公共数据的后代组件   跨越组件层级直接传递变量，实现数据共享。
1 umi.js   配置国际化  locales zh-CN.ts  选择国籍
2lang=  locale[lang.toLowerCase()]   动态判断是 哪个国家的text
3 通过createContext.Provider  传递        useContext(createContext())接收
lang['属性名']

import React, { createContext } from ‘react’;
export const Context = createContext();
 
<Context.Provider value={{selectKeysGrid, setSelectKeysGrid }}>
后代组建selectKeysGrid, setSelectKeysGrid 传递
</Context.Provider>
 
import { Context } from ‘…/…/…/…/index’;
const { selectKeysGrid, setSelectKeysGrid } = useContext(Context);
 

(4) useRef
blog.csdn.net/bingbing112…
useRef 是一个对象，它拥有一个 current 属性，并且不管函数组件执行多少次，而 useRef 返回的对象永远都是原来那一个。这个ref对象只有一个current属性，你把一个东西保存在内，它的地址一直不会变。 **useRef变化不会主动使页面渲染
所以我们可以使用useRef代替useS	tate来解决那个问题
useRef和createRef区别
createRef会在组件每次渲染的时候重新创建
useRef只会在组件首次渲染时创建
当 ref 属性用于 HTML 元素时，构造函数中使用 React.createRef() 创建的 ref 接收底层 DOM 元素作为其 current 属性。
当 ref 属性用于自定义 class 组件时，ref 对象接收组件的挂载实例作为其 current 属性。
你不能在函数组件上使用 ref 属性，因为他们没有实例。
获取子组件的实例(只有类组件可用)
在函数组件中的一个全局变量，不会因为重复 render 重复申明， 类似于类组件的 this.xxx
(5) useReducer
useReducer相当于是useState的升级版，作用与useState类似，都是用来保存状态，但它的不同点在于可以定义一个reducer的纯函数，来处理复杂数据。
(6) useCallback
父传子的函数方法 用useCallback 防止当父组件重新渲染时，函数不会重新定义==》子组件不会重新渲染
函数式组件中，每一次更新状态，自定义的函数都要进行重新的声明和定义，如果函数作为props传递给子组件，会造成子组件不必要的重新渲染，有时候子组件并没有使用到父组件发生变化的状态，此时可以使用useCallback来进行性能优化，它会为函数返回一个记忆的值，如果依赖的状态没有发生变化，那么则不会重新创建该函数，也就不会造成子组件不必要的重新渲染。
(7) useMemo
useMemo包裹的变量，相当于对变量做了缓存，当父组件重新渲染时，变量不会改变==》子组件不会重新渲染
useMemo也是返回一个记忆的值，如果依赖的内容没有发生改变的话，这个值也不会发生变化，useMemo与useCallback的不同点在于useMemo需要在传入的函数里需要return 一个值，这个值可以是对象、函数，格式如下。
8 memo
减少子组件渲染次数，即当父组件有多个子组件时，使用memo，可以让没有props变化的子组件不渲染；
memo用于包裹子组件；useCallback和useMemo用于父组件向子组件传值时，即如果是组件内部自己用的函数和变量，不需要使用useCallback和useMemo。
36 react 运行机制
React 把每一个组件当成了一个状态机，组件内部通过state来维护组件状态的变化，当组件的状态发生变化时，React通过虚拟DOM技术来增量并且高效的更新真实DOM。
内存中维护一颗虚拟DOM树，数据变化时（setState），自动更新虚拟 DOM，得到一颗新树，然后 Diff 新老虚拟 DOM 树，找到有变化的部分，得到一个 Change(Patch)，将这个 Patch 加入队列，最终批量更新这些 Patch 到 DOM 中。
1 需要虚拟dom 和diff
调和阶段(Reconciler)：官方解释。React 会自顶向下通过递归，遍历新数据生成新的 Virtual DOM，然后通过 Diff 算法，找到需要变更的元素(Patch)，放到更新队列里面去。
2 fiber
渲染阶段(Renderer) 通过 Fiber 来调度
ReactDOM.render() 和 setState 的时候开始创建更新。
将创建的更新加入任务队列，等待调度。
在 requestIdleCallback 空闲时执行任务。
从根节点开始遍历 Fiber Node，并且构建 WokeInProgress Tree。
生成 effectList。
根据 EffectList 更新 DOM。
37  结合生命周期，谈一谈React类组件的运行机制
组件的生命周期有3个主要部分：

实例化：组件被注入DOM。
存在期：组件被重新渲染来决定DOM是否应被更新。
卸载：组件从DOM中被移除。
getDefaultProps()：

对于每个组件类来说，该方法只会调用一次，该组件类的所有后续实例将不会再调用，其返回的对象可以用于设置默认的props值。
每次修改 state，都会重新渲染组件
①　shouldComponentUpdate
②　componentWillUpdate
③　render
④　componentDidUpdate

38react组件通信的几种方式
1.父子组件通信
2.跨级组件通信
3.非嵌套组件通信
父子  props  子父  props+回调函数
跨级组件通信 createContext
非嵌套组件通信 (如兄弟组件等)
PubSubJS —》npm add pubsub-js
2.引入 import PubSub from ‘pubsub-js’
若数据从A组件 传给 B组件
  (1)A组件中发布消息 
     PubSub.publish( '消息名'，data)  
  
  (2)B组件中订阅消息
     PubSub.subscribe ('消息名'， function(_,data){ }); 
 
  (3)当B组件中卸载需要取消订阅时执行
     PubSub.unsubscribe();

39谈一谈你对React受控组件的理解。
1，受控组件：
在React中默认可以完成从state到表单value的动态绑定。
给input提供onchange事件，一旦检测到文本框内容有变化，马上执行onchange事件获取表单的内容。
2，非受控组件：组件的状态更新不依赖于react
①操作DOM获取到你要的数据
ref属性接受一个回调函数，返回一个element节点 ， 通过节点获取到数据 ref={(element)=>this.addressElement = element }
② 可以在构造函数里面定义一个变量，通过变量来创建组件引用，就可以获取到这个节点
40react 组合与继承的差别
1 组件包含关系
 
      {props.children}
    
2 组合就是 既有包含关系  又有自身的props组件
41 理解jsx
注意:
1.jsx必须要有根节点
2.正常的普通HTML元素要小写，如果是大写，默认认为是组件
1.有HTML元素构成
2.中间如果需要插入变量用{}
3.{}中间可以使用表达式
4.{}中间表达式中可以使用jsx对象
5.属性和HTML内容一样都是用{}来插入内容
JSX:可理解成html，经过Bable就是运行在浏览器上的代码了。
ReactDOM.render(
element,
document.querySelector('#root')
)
42 Hoc 高阶函数 或 装饰器 或 函数柯里化
柯里化（currying）又称部分求值。一个柯里化的函数首先会接收一些参数，接收了这些参数后，该函数并不会立即求值，而是继续返回另外一个函数，刚才传入的参数在函数形成的闭包中被保存起来。待到函数被真正需要求值的时候，之前传入的所有参数都会被一次性用于求值。
具体而言，HOC就是一个函数，且该函数接受一个组件作为参数，并返回一个新组件。
高阶函数 有哪些 filter  .map
如延迟组件
进行权限判断：
页面中的按钮权限，在高阶组件中实现权限判断，页面权限判断，进行路由跳转
日志记录：
逻辑提取出来，封装成高阶组件，如果哪个组件需要进行日志处理，在组件名的外面包裹一层日志高阶组件
数据校验：
多个地方都需要进行校验数据，将逻辑拆出来，封装成高阶组件
异常处理：
进行封装异常处理，例如：异常时来个弹窗报错
withAuth.jsx文件
import React, { Component } from 'react';
const withAuth = (WrappedComponent) => {
    //返回一个新组件
    return class NweComponent extends Component {
        render() {
            if (this.props.author === "admin") {
                return <WrappedComponent {...this.props} />
            } else {
                return null;
            }
        }

    }
}
export default withAuth; 
import React, { Component } from 'react';
import withAuth from './withAuth';

class Button extends Component {
    constructor(props) {
        super(props);
        this.state = {}
    }
    render() {
        return (<button >{this.props.children}</button>);
    }
}

export default withAuth(Button); 

43 setState 同步还是异步？（比较常问）
（1）React生命周期中以及事件处理中，为异步。
（2）原生方法（setTimeout，setInnerval，addEventListener ）中是同步 。
原理：setState本身并不是异步，只是因为react的性能优化机制体现为异步。在react的生命周期函数或者作用域下为异步，在原生的环境下为同步。 因为每次调用setState都会触发更新，异步操作是为了提高性能，将多个状态合并一起更新，减少re-render调用。
性能优化机制：在 React 的 setState 函数实现中，会根据一个变量isBatchingUpdates判断是直接更新 this.state 还是放到队列中。isBatchingUpdates 默认是 false，React 在调用事件处理函数之前会将isBatchingUpdates改为true，造成的后果就是由 React 控制的事件处理过程 setState 不会同步更新 this.state。而原生方法不会被React控制。
44MVC框架的主要问题是什么？
以下是MVC框架的一些主要问题：
对 DOM 操作的代价非常高
程序运行缓慢且效率低下
内存浪费严重
由于循环依赖性，组件模型需要围绕 models 和 views 进行创建
45 Redux
详细的Redux
Redux 由以下组件组成：
Action – 这是一个用来描述发生了什么事情的对象。
Reducer – 这是一个确定状态将如何变化的地方。
Store – 整个程序的状态/对象树保存在Store中。
View – 只显示 Store 提供的数据。
先简单说一下redux和react是怎么配合的。react-redux提供了connect和Provider两个好基友，它们一个将组件与redux关联起来，一个将store传给组件。组件通过dispatch发出action，store根据action的type属性调用对应的reducer并传入state和这个action，reducer对state进行处理并返回一个新的state放入store，connect监听到store发生变化，调用setState更新组件，此时组件的props也就跟着变化。
1遵从三个原则
单一事实来源：整个应用的状态存储在单个 store 中的对象/状态树里。单一状态树可以更容易地跟踪随时间的变化，并调试或检查应用程序。
状态是只读的：改变状态的唯一方法是去触发一个动作。动作是描述变化的普通 JS 对象。就像 state 是数据的最小表示一样，该操作是对数据更改的最小表示。
使用纯函数进行更改：为了指定状态树如何通过操作进行转换，你需要纯函数。纯函数是那些返回值仅取决于其参数值的函数。
46以你的做过一个react项目为例，说一说如何优雅地地实践组件化和数据流管理？
模块化：抽取业务中的重复逻辑，自定义成hook
组件化：基于使用的UI库，根据业务自底向上封装更复杂的黑盒组件
数据流管理：在hook出现，数据流管理变得更加简便。页面中有自己的数据流，如果是一个公用的数据，可以使用useModel放到全局。
47什么是React合成事件？为什么存在合成事件？有什么特点？
React合成事件是React 模拟原生DOM事件所有能力 的一个事件对象。
根据 W3C规范 来定义合成事件，兼容所有浏览器，拥有与浏览器原声事件相同的接口。合成事件除了拥有和浏览器原生事件相同的接口，包括stopPropagetion()和preventDefault()；在React中，所有事件都是合成的，不是原生DOM事件
为什么出现这个技术？
浏览器兼容，实现更好的跨平台。顶层事件代理机制：保证冒泡一致性，可以跨浏览器执行。将不同平台事件模拟成合成事件；
避免垃圾回收。React引入事件池，在事件池中获取或释放事件对象。React事件对象不会被释放掉，而是存入一个数组中；当事件触发，就从这个数组中弹出，避免频繁地创建和销毁（垃圾回收）；
方便事件统一管理和事务机制
47 从React的角度，说一说有哪些性能优化策略。
列表渲染的时候加key；
在函数组件中使用useCallback和useMemo来进行组件优化，依赖没有变化的话，不重复执行；
合理设计组件，减少props和state
49 dva
dva
50安全性
1 应用场景 引用第三方网站
windows.open 和a超链接跳转
跳转后用户正在浏览新标签页，但是原来网站的标签页已经被导航到了百度页面。

恶意网站可以伪造一个足以欺骗用户的页面，使得进行恶意破坏。

window.opener.location.replace('www.baidu.com')    调用父窗口的方法
<a target="_blank" href="" rel="noopener noreferrer nofollow">a标签跳转url</a>

<!-- 
  通过 rel 属性进行控制：
  noopener：会将 window.opener 置空，从而源标签页不会进行跳转（存在浏览器兼容问题）
  noreferrer：兼容老浏览器/火狐。禁用HTTP头部Referer属性（后端方式）。
  nofollow：SEO权重优化，详情见 https://blog.csdn.net/qq_33981438/article/details/80909881
 -->

<button onclick='openurl("http://www.baidu.com")'>click跳转</button>

function openurl(url) {
    var newTab = window.open();
    newTab.opener = null;
    newTab.location = url;
}

2iframe
a.如何让自己的网站不被其他网站的 iframe 引用？
// 检测当前网站是否被第三方iframe引用
// 若相等证明没有被第三方引用，若不等证明被第三方引用。当发现被引用时强制跳转百度。
if(top.location != self.location){
    top.location.href = 'http://www.baidu.com'
}

// 检测当前网站是否被第三方iframe引用
// 若相等证明没有被第三方引用，若不等证明被第三方引用。当发现被引用时强制跳转百度。
if(top.location != self.location){
top.location.href = 'www.baidu.com'
}
b.如何禁用，被使用的 iframe 对当前网站某些操作？
sandbox是html5的新属性，主要是提高iframe安全系数。iframe因安全问题而臭名昭著，这主要是因为iframe常被用于嵌入到第三方中，然后执行某些恶意操作。
现在有一场景：我的网站需要 iframe 引用某网站，但是不想被该网站操作DOM、不想加载某些js（广告、弹框等）、当前窗口被强行跳转链接等，我们可以设置 sandbox 属性。如使用多项用空格分隔。
allow-same-origin：允许被视为同源，即可操作父级DOM或cookie等
allow-top-navigation：允许当前iframe的引用网页通过url跳转链接或加载
allow-forms：允许表单提交
allow-scripts：允许执行脚本文件
allow-popups：允许浏览器打开新窗口进行跳转
“”：设置为空时上面所有允许全部禁止
3 CSRF / XSRF（跨站请求伪造）
你可以这么理解 CSRF 攻击：攻击者盗用了你的身份，以你的名义进行恶意请求。它能做的事情有很多包括：以你的名义发送邮件、发信息、盗取账号、购买商品、虚拟货币转账等。总结起来就是：个人隐私暴露及财产安全问题。

阐述 CSRF 攻击思想：（核心2和3）    挟持cookie 请求
1、浏览并登录信任网站（举例：淘宝）
2、登录成功后在浏览器产生信息存储（举例：cookie）
3、用户在没有登出淘宝的情况下，访问危险网站
4、危险网站中存在恶意代码，代码为发送一个恶意请求（举例：购买商品/余额转账）
5、携带刚刚在浏览器产生的信息进行恶意请求
6、淘宝验证请求为合法请求（区分不出是否是该用户发送）
7、达到了恶意目标

*/
防御措施（推荐添加token / HTTP头自定义属性）
涉及到数据修改操作严格使用 post 请求而不是 get 请求
HTTP 协议中使用 Referer 属性来确定请求来源进行过滤（禁止外域） （也可以设置防盗链）
请求地址添加 token ，使黑客无法伪造用户请求
HTTP 头自定义属性验证（类似上一条）
显示验证方式：添加验证码、密码等
4 接口 referer 设置防盗链
5 XSS/CSS（跨站脚本攻击）
反射性 （请求）存储型（数据库） dom型
XSS又叫CSS（Cross Site Script），跨站脚本攻击：攻击者在目标网站植入恶意脚本（js / html），用户在浏览器上运行时可以获取用户敏感信息（cookie / session）、修改web页面以欺骗用户、与其他漏洞相结合形成蠕虫等
防御措施（对用户输入内容和服务端返回内容进行过滤和转译）
React 在渲染 HTML 内容和渲染 DOM 属性时都会将 "'&<> 这几个字符进行转义，转义部分源码。 源码大概就是switch
JSX 语法
JSX 实际上是一种语法糖，Babel 会把 JSX 编译成 React.createElement() 的函数调用，最终返回一个 ReactElement 实例，
// JSX
const element = (
  <h1 className="greeting">
    Hello, world!
  </h1>
);
// 通过 babel 编译后的代码
const element = React.createElement(
  'h1',
  {className: 'greeting'},
  'Hello, world!'
);
// React.createElement() 方法返回的 ReactElement
const element = {
  $$typeof: Symbol('react.element'),
  type: 'h1',
  key: null,
  props: {
    children: 'Hello, world!',
      className: 'greeting'   
  }
  ...
}

注意到其中有个属性是 typeof，它是用来标记此对象是一个ReactElement，React在进行渲染前会通过此属性进行校验，校验不通过将会抛出上面的错误。React利用这个属性来防止通过构造特殊的Children来进行的XSS攻击，原因是typeof，它是用来标记此对象是一个 ReactElement，React 在进行渲染前会通过此属性进行校验，校验不通过将会抛出上面的错误。React 利用这个属性来防止通过构造特殊的 Children 来进行的 XSS 攻击，原因是 typeof，它是用来标记此对象是一个ReactElement，React在进行渲染前会通过此属性进行校验，校验不通过将会抛出上面的错误。React利用这个属性来防止通过构造特殊的Children来进行的XSS攻击，原因是typeof 是个 Symbol 类型，进行 JSON 转换后会 Symbol 值会丢失，无法在前后端进行传输。如果用户提交了特殊的 Children，也无法进行渲染，利用此特性，可以防止存储型的 XSS 攻击。
一定要注意 dangerouslySetInnerHTML  不会进行转译
现代大部分浏览器都自带 XSS 筛选器，vue / react 等成熟框架也对 XSS 进行一些防护
即便如此，我们在开发时也要注意和小心
对用户输入内容和服务端返回内容进行过滤和转译
重要内容加密传输
合理使用get/post等请求方式
对于URL携带参数谨慎使用
我们无法做到彻底阻止，但是能增加黑客攻击成本，当成本与利益不符时自然会降低风险
xss.js 白名单输出允许的html标签
51 同源策略
同源指的是我们访问站点的：协议、域名、端口号必须一至，才叫同源。
浏览器默认同源之间的站点是可以相互访问资源和操作DOM的，而不同源之间想要互相访问资源或者操作DOM，那就需要加一些安全策略的限制，俗称同源策略
同源策略主要限制了三个方面：
DOM层面：不同源站点之间不能相互访问和操作DOM
数据层面：不能获取不同源站点的Cookie、LocalStorage、indexDB等数据
网络层面：不能通过XMLHttpRequest向不同源站点发送请求
当然同源策略限制也不是绝对隔离不同源的站点，比如link、img、script标签都没有跨域限制，这让我们开发更灵活了，但是也同样带来了一些安全问题，也就是浏览器网络安全问题，最典型的就是XSS攻击和CSRF攻击
52 跨域
前端框架的一般设置跨域代理 proxy对象  react proxy.ts  生产环境 测试环境都可以设置
cors
CORS 需要浏览器和后端同时支持。IE 8 和 9 需要通过 XDomainRequest 来实现。
浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。
服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。
postMessage
// 发送消息
const targetWindow = window.open('http://localhost:10001/user');
setTimeout(()=>{
     targetWindow.postMessage('来自10002的消息', 'http://localhost:10001')
}, 3000)

window.addEventListener('message', (e) => {
     console.log(e.data)
     if (event.origin !== "http://localhost:10002") 
     return;
     e.source.postMessage('来自10001的消息', e.origin)
})

postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：
页面和其打开的新窗口的数据传递
多窗口之间消息传递
页面与嵌套的iframe消息传递
上面三个场景的跨域数据传递
postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递。
websocket
Websocket是HTML5的一个持久化的协议，它实现了浏览器与服务器的全双工通信，同时也是跨域的一种解决方案。WebSocket和HTTP都是应用层协议，都基于 TCP 协议。但是 WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据。同时，WebSocket 在建立连接时需要借助 HTTP 协议，连接建立好了之后 client 与 server 之间的双向通信就与 HTTP 无关了。
try {
      const socket = new WebSocket(
        `${initialState?.businessInfo.socketAddress}${buildTransferUrl}/${importRecordId}`,
      );

      // Connection opened
      socket.addEventListener('open', () => {
        socketRef.current = socket;
        // socket.send('Hello Server!');
      });

      socket.addEventListener('close', () => {});

      // Listen for messages
      socket.addEventListener('message', (e) => {
        const data = JSON.parse(e.data);
        setProgress(parseInt((data.num / data.total) * 100 + ''));
        setShowProgress(data.num + '/' + data.total);
        if (data.num >= data.total) {
          setTableSpanding(false);
          setWebsokcketFlag(false);
          message.info(messageInfo);
          setMyButtonFlag(true);
        }
      });

原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容
Node中间件代理(两次跨域)
实现原理：同源策略是浏览器需要遵循的标准，而如果是服务器向服务器请求就无需遵循同源策略。 代理服务器，需要做以下几个步骤：
接受客户端请求 。
将请求 转发给服务器。
拿到服务器 响应 数据。
将 响应 转发给客户端。
nginx反向代理
实现原理类似于Node中间件代理，需要你搭建一个中转nginx服务器，用于转发请求。
使用nginx反向代理实现跨域，是最简单的跨域方式。只需要修改nginx的配置即可解决跨域问题，支持所有浏览器，支持session，不需要修改任何代码，并且不会影响服务器性能。
实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。
window.name + iframe
window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。
总结：通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。
location.hash + iframe
实现原理： a.html欲与c.html跨域相互通信，通过中间页b.html来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。
具体实现步骤：一开始a.html给c.html传一个hash值，然后c.html收到hash值后，再把hash值传递给b.html，最后b.html将结果放到a.html的hash值中。 同样的，a.html和b.html是同域的，都是http://localhost:3000;而c.html是http://localhost:4000
document.domain + iframe
该方式只能用于二级域名相同的情况下，比如a.test.com和b.test.com适用于该方式。 只需要给页面添加document.domain ='test.com'表示二级域名都相同就可以实现跨域。
实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。
52 http1.x 和http2.x区别
参考答案：
http1.x 和http2.x主要有以下4个区别：
HTTP2使用的是二进制传送，HTTP1.X是文本（字符串）传送。
二进制传送的单位是帧和流。帧组成了流，同时流还有流ID标示
HTTP2支持多路复用
因为有流ID，所以通过同一个http请求实现多个http请求传输变成了可能，可以通过流ID来标示究竟是哪个流从而定位到是哪个http请求
HTTP2头部压缩
HTTP2通过gzip和compress压缩头部然后再发送，同时客户端和服务器端同时维护一张头信息表，所有字段都记录在这张表中，这样后面每次传输只需要传输表里面的索引Id就行，通过索引ID查询表头的值
HTTP2支持服务器推送
HTTP2支持在未经客户端许可的情况下，主动向客户端推送内容
53 http缓存有几种？
参考答案：
http缓存的分类：
根据是否需要重新向服务器发起请求来分类，可分为(强制缓存，协商缓存) 根据是否可以被单个或者多个用户使用来分类，可分为(私有缓存，共享缓存) 强制缓存如果生效，不需要再和服务器发生交互，而协商缓存不管是否生效，都需要与服务端发生交互。下面是强制缓存和协商缓存的一些对比：
1.1、强制缓存
强制缓存在缓存数据未失效的情况下（即Cache-Control的max-age没有过期或者Expires的缓存时间没有过期），那么就会直接使用浏览器的缓存数据，不会再向服务器发送任何请求。强制缓存生效时，http状态码为200。这种方式页面的加载速度是最快的，性能也是很好的，但是在这期间，如果服务器端的资源修改了，页面上是拿不到的，因为它不会再向服务器发请求了。这种情况就是我们在开发种经常遇到的，比如你修改了页面上的某个样式，在页面上刷新了但没有生效，因为走的是强缓存，所以Ctrl + F5一顿操作之后就好了。 跟强制缓存相关的header头属性有（Pragma/Cache-Control/Expires）， Pragma和Cache-control共存时，Pragma的优先级是比Cache-Control高的。
1.2、协商缓存
当第一次请求时服务器返回的响应头中没有Cache-Control和Expires或者Cache-Control和Expires过期还或者它的属性设置为no-cache时(即不走强缓存)，那么浏览器第二次请求时就会与服务器进行协商，与服务器端对比判断资源是否进行了修改更新。如果服务器端的资源没有修改，那么就会返回304状态码，告诉浏览器可以使用缓存中的数据，这样就减少了服务器的数据传输压力。如果数据有更新就会返回200状态码，服务器就会返回更新后的资源并且将缓存信息一起返回。跟协商缓存相关的header头属性有（ETag/If-Not-Match 、Last-Modified/If-Modified-Since）请求头和响应头需要成对出现
1.3、私有缓存（浏览器级缓存）
私有缓存只能用于单独的用户：Cache-Control: Private
1.4、共享缓存（代理级缓存）
共享缓存可以被多个用户使用: Cache-Control: Public
5.26 协商缓存原理，谁跟谁协商，如何协商？
参考答案：
协商缓存: 向服务器发送请求，服务器会根据这个请求的request header的一些参数来判断是否命中协商缓存，如果命中，则返回304状态码并带上新的response header通知浏览器从缓存中读取资源；
服务器和请求协商，根据请求头携带的参数进行协商
54  get post区别
get用来获取数据，post用来提交数据
get参数有长度限制（受限于url长度，具体的数值取决于浏览器和服务器的限制，最长2048字节），而post无限制
get请求的数据会附加在url之 ，以 " ？ "分割url和传输数据，多个参数用 "&"连接，而post请求会把请求的数据放在http请求体中。
get是明文传输，post是放在请求体中，但是开发者可以通过抓包工具看到，也相当于是明文的。
get请求会保存在浏览器历史记录中，还可能保存在web服务器的日志中
55 浏览器从输入URL到页面加载的全过程
1 ,URL解析 2, 缓存检查 （资源缓存 强缓存 协商缓存 所有资源请求都是get请求，）
从输入URL到页面加载的主干流程如下：
1、浏览器的地址栏输入URL并按下回车。
2、浏览器查找当前URL的DNS缓存记录。
（1、器中输入www.baidu.com域名，操作系统会先查hosts件是否有记录，有的话就会把相对应映射的IP返回。
2、hosts文件没有就去查本地dns解析器有没有缓存。（这个我没答上来）
3、然后就去找我们计算机上配置的dns服务器上有或者有缓存，就返回
4、还没有的话就去找根DNS服务器(全球13台，固定ip地址)，然后判断.com域名是哪个服务器管理，如果无法解析，就查找.baidu.com服务器是否能解析，直到查到www.baidu.com的IP地址）
3、DNS解析URL对应的IP。
4、根据IP建立TCP连接（三次握手）。
第三次握手是为了防止失效的请求连接到达服务器，让服务器错误的打开连接。第二次握手，主机B还不能确认主机A已经收到确认请求，也是说B认为建立好连接，开始发数据了，结果发出去的包一直A都没收到，那攻击B就很容易了，我专门发包不接收，服务器很容易就挂了。
（1 第一次握手由客户端发送资源包给到服务端，若该过程正常，则得出结论：服务端接收、客户端发送服务正常
2   第二次握手由服务端发送资源包给到客户端，若该过程正常，则得出结论：服务端发送、客户端接收服务正常
3 第三次握手由客户端发送资源包给到服务端，若该过程正常，则得出结论：服务端接收、客户端发送服务正常）
5、HTTP发起请求。
浏览器首次加载资源成功时，服务器返回200，此时浏览器不仅将资源下载下来，而且把response的header(里面的date属性非常重要，用来计算第二次相同资源时当前时间和date的时间差)一并缓存;
下一次加载资源时，首先要经过强缓存的处理，cache-control的优先级最高，比如cache-control：no-cache,就直接进入到协商缓存的步骤了，如果cache-control：max-age=xxx,就会先比较当前时间和上一次返回200时的时间差，如果没有超过max-age，命中强缓存，不发请求直接从本地缓存读取该文件（这里需要注意，如果没有cache-control，会取expires的值，来对比是否过期），过期的话会进入下一个阶段，协商缓存
协商缓存阶段，则向服务器发送header带有If-None-Match和If-Modified-Since的请求，服务器会比较Etag，如果相同，命中协商缓存，返回304；如果不一致则有改动，直接返回新的资源文件带上新的Etag值并返回200;
协商缓存第二个重要的字段是，If-Modified-Since，如果客户端发送的If-Modified-Since的值跟服务器端获取的文件最近改动的时间，一致则命中协商缓存，返回304；不一致则返回新的last-modified和文件并返回200;
谷歌中200 from disk cache和from memory cache  硬盘缓存  内存缓存
火狐是 304
强缓存：
1、先查找内存，如果内存中存在，从内存中加载；
2、如果内存中未查找到，选择硬盘获取，如果硬盘中有，从硬盘中加载；
3、如果硬盘中未查找到，那就进行网络请求；
4、加载到的资源缓存到硬盘和内存；
6、服务器处理请求，浏览器接收HTTP响应。
7、渲染页面，构建DOM树。
构建DOM树(DOM tree)：从上到下解析HTML文档生成DOM节点树（DOM tree），也叫内容树（content tree）；
构建CSSOM(CSS Object Model)树：加载解析样式生成CSSOM树；
执行JavaScript：加载并执行JavaScript代码（包括内联代码或外联JavaScript文件）；
构建渲染树(render tree)：根据DOM树和CSSOM树,生成渲染树(render tree)；
渲染树：按顺序展示在屏幕上的一系列矩形，这些矩形带有字体，颜色和尺寸等视觉属性。
布局（layout）：根据渲染树将节点树的每一个节点布局在屏幕上的正确位置；
绘制（painting）：遍历渲染树绘制所有节点，为每一个节点适用对应的样式，这一过程是通过UI后端模块完成；
8、关闭TCP连接（四次挥手）。
56 页面渲染优化
HTML文档结构层次尽量少，最好不深于六层；
脚本尽量后放，放在前即可；
少量首屏样式内联放在标签内；
样式结构层次尽量简单；
在脚本中尽量减少DOM操作，尽量缓存访问DOM的样式信息，避免过度触发回流；
减少通过JavaScript代码修改元素样式，尽量使用修改class名方式操作样式或动画；
动画尽量使用在绝对定位或固定定位的元素上；
隐藏在屏幕外，或在页面滚动时，尽量停止动画；
尽量缓存DOM查找，查找器尽量简洁；
